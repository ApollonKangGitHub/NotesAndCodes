http://www.watchmen.cn/video/linux/

一、
B树（二叉排序树、二叉搜索树）：左子树小于根节点，右子树大于根节点，递归满足。
满二叉树：每一个节点左子树与右子树同时存在，递归满足。所以其节点数为[N=2^n-1],n为深度
满二叉排序树：既满足B树特点又满足满二叉树特点的树。
完全二叉树：除了最底层的叶子节点外，其它层均满，并且最底层叶子节点都集中在最左边

二、
AVL树(平衡二叉排序树)：首先满足：二叉、排序两个特点，另外还满足左右节点的左右子树的高度差不超过1
	AVL树的编程核心：再加入新的元素，使之依然为AVL树。也就是说AVL树的插入操作其核心是保证其平衡性依旧.
	旋转是消除插入时可能会引起的不平衡问题的有效方法。
三、
哈希算法：
常见的数据组织方式：数组、链表、树，数据组织的目的是为了存储，而数据存储采用不同的组织方式的目的是为了以后的查找方便。
(1)、普通逐个查找：时间复杂度O(n)、
(2)、排序好的二分查找：时间复杂度O(log2N)、
(3)、二叉排序的AVL的组织方式(也是排序的)：时间复杂度O(log2N)
以上方式是与数据量N有关系的，显然数据量越大查找的时间越长。无法保证在一定时间内找到任意给定大小的数据量的key值。

针对于查找速率，Hash可以说是最快的：
哈希算法采用哈希函数将不同数据映射到数组不同的下标中，而哈希算法要解决的是唯一映射的问题，
这个是散列度决定的，并且哈希算法需要较大的空间，至少比O(n)大好几倍，否则产生冲突的概率很高。
而Hash算法作为一种时间复杂度与N无关的算法，即O(1)，指的是在散列度好的情况下是O(1)。

Hash的两个问题：
(1)、找散列度好的函数(属于数学问题)：我们(普通程序员)只要知道其原理，并且会选择使用场景的哈希函数与使用之。
(2)、扩展的问题

找散列度好的函数(使用原则与特点)：
(1)、选择的数组的存储空间最好是质数【提高散列度】
(2)、运算的时间值与字符串长度是相关的【区别不同的字符串】
(3)、大量的位运算【计算机对位运算计算的更快】
(4)、仍然没有一个函数可以完全解决冲突问题即两个不同的字符串可能映射到同一个值。

解决哈希冲突的问题：
(1)、开地址法：如果有冲突就向下寻找空的存储空间来存放(但是需要数据总量少于数组存储空间大小)。
(2)、拉链法：每个单元加入链式结构，如果冲突放在链表后面。