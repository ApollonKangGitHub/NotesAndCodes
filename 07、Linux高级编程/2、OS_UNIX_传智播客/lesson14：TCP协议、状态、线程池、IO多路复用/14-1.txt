1、建立链接协议（三次握手）
（1）客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的报文1。
（2） 服务器端回应客户端的，这是三次握手中的第2个报文，这个报文同时带ACK标志和SYN标志。因此它表示对刚才客户端SYN报文的回应；同时又标志SYN给客户端，询问客户端是否准备好进行数据通讯。
（3） 客户必须再次回应服务段一个ACK报文，这是报文段3。

2、连接终止协议（四次握手）
　 　由于TCP链接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送（报文段4）。
（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。
（3） 服务器关闭客户端的连接，发送一个FIN给客户端（报文段6）。
（4） 客户段发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。

几个重要的TCP连接状态：
FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别 是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即 进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马 上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。

FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。
TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什 么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报 文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。

CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对 方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。

LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。

MSL一般为30s、1min、2min等(2MSL即1分钟、2分钟、4分钟)
--------------------------------------------------------------------------------------------------------------------------------------
滑动窗口流量控制：流量控制处理机制
每次在发包通信的时候，都携带当前剩余缓冲区的大小的信息。

TCP半链接状态：
当A关闭链接，B回复ACK以后，A处于FINSH_WAIT2状态，A可以接收B发送的数据包但是不能再发数据包(可以回复ACK应答)。这种状态称为半连接状态。
用函数控制：
int shutdown(int sockfd, int how);
sockfd: 需要关闭的socket的描述符
how:允许为shutdown操作选择以下几种方式:
SHUT_RD：关闭链接的读端。也就是该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被丢弃。进程将不能对该套接字发出任何读操作。对 TCP套接字该调用之后接受到的任何数据将被确认然后无声的丢弃掉。SHUT_WR:关闭连接的写端，进程不能在对此套接字发出写操作SHUT_RDWR:相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。shutdown可以选择终止一个方向的连接。

使用close中止一个链接，但它只是减少描述符的参考数，并不直接关闭连接，只有当描述符的参考数为0时才关闭连接。 shutdown可直接关闭描述符，不考虑描述符的参考数，可选择中止一个方向的连接。
注意:
 1>. 如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。
 2>. 在多进程中如果一个进程中shutdown(sfd, SHUT_RDWR)后其它的进程将无法进行通信. 但是如果一个进程close(sfd)将不会影响到其它进程. 

--------------------------------------------------------------------------------------------------------------------------------------
线程池并发服务器模型：

①第一种模型：每个线程都阻塞在accept上，当有客户端链接时，阻塞再accept上的线程都被唤醒，竞争accept接收的链接，最终只有一个线程去处理，其它线程则继续阻塞。然而唤醒所有却只有一个能够处理链接，其它则继续去阻塞，产生“惊群”效应。对于这种情况可以使用pthread_coond_signal()只唤醒一个。

②第二种模型：设置一个主控线程，主控线程accept，其它任务线程等待主控线程分配任务。可用信号量/条件变量实现。
③每个线程先抢占一把锁(互斥量mutex)，谁去accept。(效率最高，但是并不是甩其他方法一条街)如下：
pthread_mutex_lock(&mutex);
accept(listenfd, &addr, &addrlen);
pthread_mutex_unlock(&mutex);

对于线程池的线程个数需要进行设置(阈值)，max_work_num(最大)、min_work_num(最小)、cur_work_num(当前线程数)、this_work_num(当前使用的线程数)等值

int pthread_kill(pthread_t thread, int sig);//向指定线程发送信号，作用域仅限于当前进程。