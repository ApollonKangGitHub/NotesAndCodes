进程间通信：

1、管道：无名管道pipe：
#include<unistd.h>
int pipe(int filedes[2]);//创建无名管道，由内核维护，且无名管道只能用于fork创建的父子进程之间通信(作用于有血缘关系的进程间通信)。局限，但是经典(稳定)。

管道使用注意的四种情况：
①当写端关闭，读端读完管道里内容时read返回0，相当与读到文件末尾；
②写端未关闭，但是写端暂无数据，读端读完管道中数据后便阻塞；
③读端关闭，写管道的进程会收到一个SIGPIPE信号，写进程终止；
④读端未读管道数据，当写端写满数据后，再次写会阻塞。

对于非阻塞管道的实现，可以用fcntl函数设置O_NOBLOCK标志。
fpathconf(int fd, int name);测试管道缓冲区大小，name采用_PC_PIPE_BUF参数测试。
----------------------------------------------------------------
2、管道：有名管道fifo：
mkfifio或者mkfifo()创建后缀名为.fifo的管道文件。后缀名无所谓，但是创建的方式只能是以上两种方式。

mkfifo(cosnt char * pathname, mode_t mode);
管道文件只用创建一个，所以无论是读端还是写端。在创建管道之前，先判断管道文件是否存在(access函数的F_OK参数)，存在就不用创建，否则自己创建，另外一段就不需要创建了。
有名管道本质：无血缘关系的两个进程通过name.pipe管道文件找到内核中的pipe管道，进而实现无血缘关系的管道进程间通信。

注意：管道只在内核中占用一小部分内存，而管道文件不会在磁盘上占用空间(管道文件的PCB在内核中占用内存，只消耗一个inode)。
----------------------------------------------------------------
3、内存共享映射函数：
mmap、munmap：
mmap函数可以把磁盘文件的一部分直接映射进内存，这样文件的位置就有了对应的地址，对于文件的都写可以直接使用指针，而不需要read与write。

void * mmap(void * addr, size_t length, int port, int flags, int fd, off_t offset);

addr：为映射的内存起始位置，设置为NULL操作系统自动分配；
length：映射的长度；
port：内存访问权限，PORT_NONE、PORT_EXEC、PORT_READ、PORT_WRITE
flags：属性，MAP_SHARED(磁盘/内存任意一处修改同步到另外一处)、MAP_PRIVATE(磁盘/内存任意一处修改不影响另外一处)；
fd：文件描述符(映射文件已打开)，如不映射文件，只申请内存时值为-1；
offset：偏移量(文件的映射长度)：4096整数倍；
返回值：返回系统分配的addr起始地址，失败返回MAP_FAILED。

int munmap(void * addr, size_t length);

注意：close(fd);并不会解除映射，close只是将file结构体计数减1，并不会对映射关系产生影响。