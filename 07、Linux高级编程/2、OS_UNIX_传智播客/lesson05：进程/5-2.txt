getuid()返回实际用户id
geteuid()返回有效用户id

getgid()返回实际用户组id
getegid()返回有效用户组id

passwd文件(/usr/bin/passwd)设置了用户id(s位)：rwsr-xr-x，当普通用户passwd设置密码时具有了root权限(有效用户成为root，实际用户还是普通房用户),(执行passwd并不需要sudo)。
sudo chmod 04777 file即可设置用户id(s位)
sudo chmod 06777 file即可设置组id(s位)
sudo chmod 07777 file即可设置粘滞位(t位)

----------------------------------------------------------------
vfork()函数：
与execl函数共同结合使用。
由于早期fork()函数不支持读时共享写时复制，所以vfork()还用用武之地。但是现在fork()经过优化之后，支持读时共享写时复制，就可以fork()与execl()结合使用从而废弃vfork()函数了。

exec家族函数中各个字母的意思：
l：使用命令行参数列表
p：搜索file时使用PATH变量
v：使用命令行参数数组
e：使用环境变量数组，不适用进程原有环境变量，设置新的加载程序运行的环境变量(自定义)。

shell的部分实现就是基于exec家族函数实现。子进程执行命令shell就进入后台，子进程结束后父进程又回到前台。

		shell
		/  \
	       /    \
	    shell  子进程(执行命令)

execl家族与execv家族区别：
①char *argvv[] = {"ls","-l",NULL};
execv("/bin/ls", argvv);
②execl("/bin/ls","ls","-l",NULL);


所有的execl()与execv()族底层都是调用execve().
注意：exec函数调用成功是没有返回值的，因为调用成功的返回值返回给原来的代码段，而exec调用的代码将预案有待码覆盖掉了，所以即使成功有返回值也没有意义。所以我们可以这样写：
exec(....);
perror("..");
不需要再判断返回值，因为能执行到perror代表肯定出错了。

注意：exec函数不需要第一个参数与第二个参数必须相对应：
execl("/bin/ls","hehe","-l",NULL);
即使是hehe，但是一个参数已经告诉了可执行程序的命令与路径。所以第二个参数只是一个幌子(但是不能不要该参数：第一个参数不能错，第二个可错但是不能少)。
----------------------------------------------------------------
① > file:输出重定向
② < file:输入重定向

如果一个进程已经结束，父进程没有对其进行资源(内核PCB资源)回收(waitpid()/wait())，那么该进程就成为一个僵尸进程。测试时可以让父进程死循环，而子进程睡眠几秒就可以观察到：虽然子进程已经结束，并且返回，但是父进程一直没有结束，不能对其子进程PCB资源回收，所以子进程就成了僵尸进程。而对于父进程先结束，也不等待(waitpid()/wait())，子进程就会成为孤儿进程，但是孤儿进程的资源会由init回收，所以不会成为僵尸进程。我们可以知道：任何进程在刚结束时均处于僵尸态，只不过一般子进程结束，父进程就已经将子进程PCB回收了。

总结：
孤儿进程：子进程结束，父进程没有回收子进程资源(PCB资源)。
僵尸进程：父进程先结束--init成为孤儿进程的父进程。
孤儿进程并不可怕，僵尸进程可怕。所以使用wait/waitpid要避免僵尸进程
----------------------------------------------------------------
wait()只能回收第一个结束的子进程。若该进程无子进程，wait不会阻塞。
waitpid()则可以指定的子进程多个。

(1)、wait(int * status);
status取到子进程返回值、结束时收到的信号等信息(八位存一种信息)。
(2)、waitpid(pid_t pid, int * status, int options);
①pid<-1:回收指定进程组任意进程(谁先结束回收谁),该进程组必须与调用waitpid的进程有“血缘关系”；
②pid=-1:回收任意子进程；
③pid=0:回收和调用waitpid的进程同组的进程；
④pid>0:回收指定pid的子进程。

kill -9 -gid:向一个进程组发送9号信号(fork创建的子进程与父进程隶属于同一个组)
ps -ajx:可以查看pid、ppid、gid等。

options：
WNOHANG：如果无子进程结束，立即返回(即不阻塞)；
WUNTRACED、WCONTINUED等。

一组宏函数用来获取status信息：
WIFEXITED(status)：正常结束返回真，异常结束放回假
WEXITSTATUS(status)：如果正常退出才调用，获取正常退出的退出码

WIFSIGANLED(status)：被信号终止则返回真
WTERMSIG(status);如果进程被信号终止才调用，返回信号的编号
......
----------------------------------------------------------------
练习：
①实现多进程拷贝命令
②实现多进程打印输出