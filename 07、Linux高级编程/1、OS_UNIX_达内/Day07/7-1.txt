回顾：
	①文件相关 --文件锁
	文件锁主要是读写锁，正确用法是在调用度函数之前加读锁，在调用写函数之前加写锁，使用完毕后释放锁。如果需要在加锁资源暂时不可用时进入阻塞状态使用F_SETLKW实现。
	②文件相关函数
	stat()、access()、chmod()、mmap()、truncate()等
	mmap()与fd结合使用，让虚拟内存地址映射文件。mmap和open的权限保持一致，一般都是读写权限。
	③目录相关函数 -- 4（操作目录）+2（读目录）个函数
	(System Call):mkdir()、rmdir()、chdir()、getcwd()
	(标准库函数):opendir()、readdir()
----------------------------------------------------------------
进程：一个在内存中运行的程序
Linux中查看进程：
	ps：查看本终端启动的进程
	ps -aux：Linux专用查看进程（ps -aux | more），UNIX不直接支持该方法（间接支持：/usr/ucb/ps -aux即可），因为UNIX下ps的PATH路径只包括/usr/bin/ps，它不支持ps -aux。但/usr/ucb/ps支持。而Linux下ps只有/usr/bin/ps一个路径。
	ps -ef：Unix/Linux通用的查看进程方式（ps -ef | more）
杀死进程：
	kill -9 pid：杀死pid对应的进程。
进程常见状态：
	S：休眠状态Sleep（省资源）
	s：表示改进程有子进程
	O：可运行状态
	R：正在运行状态
	Z：僵尸进程（僵尸状态），已经结束但资源没有完全回收
父子进程的关系：
	①在宏观上，父子进程同时运行（时间片很小）。
	②如果子进程先结束，子进程会给父进程发送一个信号，由父进程回收子进程的相关资源。
	③如果父进程先结束，会给自己的父进程福信号，但子进程不会被父进程回收资源。成为孤儿进程，init（pid=1）成为孤儿进程的父进程，init则负责回收孤儿进程运行完毕的资源。
	④子进程先结束，同时发送信号但父进程没有收到，或者子进程根本就没有发送信号，（子进程在父进程结束以前结束了不会成为孤儿进程，但资源没被回收），子进程就变成了僵尸进程。
----------------------------------------------------------------
每个进程都有一个非负整型表示的唯一进程ID。ID唯一但可以重用，当一个进程正常终止后，其原占ID就可以再次使用（延迟重用）。
getuid获取实际用户id、geteuid获取有效用户id
getgid获取实际组id、getegid获取有效id
（实际id不重要，有效id重要）

1、fork()/vfork()

fork()通过复制自身（父进程）创建新进程（子进程）。并非完全复制，子进程会复制父进程代码区之外的内存区域（物理内存的数据&虚拟内存的地址），即和父进程共享代码区（因为代码区是只读的，所以可以共享）。而虚拟内存各占独立一套。
#include<stdio.h>
#include<unistd.h>

int main(void)
{
	pid_t pid = fork();
	if(pid == 0)
		printf("我是子进程我的进程id=%d，父进程pid=%d,子进程pid=%d",getpid(),getppid(),pid);
	else
		printf("我是父进程我的进程id=%d，父进程pid=%d,子进程pid=%d",getpid(),getppid(),pid);

	sleep(1);
	return 0;
}