fork()之后父子进程同时运行，但谁先执行谁后执行在不同操作系统中的调度算法不尽相同（因为标准中没有规定）。如果在fork()之后公共代码（都会执行的代码）中对文件加写锁，后执行的进程会加锁失败等问题。

----------------------------------------------------------------
fork()复制文件描述符：
在fork()之前打开的文件，其文件描述符会被复制，而fork()之后打开的文件，其文件描述符不会被复制，只是父子进程各自打开。复制文件描述符时，只复制描述符，不复制文件表，即两个几进程共用一张文件表，一个偏移量，父子进程修改文件不会覆盖，只会追加。
----------------------------------------------------------------
练习：模拟聊天室。
	启动10个子进程，每个子进程休眠1秒，然后输出XXX（进程id代表用户）退出聊天室。
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

int main (void){
	int num = 10;
	while(num--){
		pid_t pid = fork();/*父进程只执行循环中这一句*/
		if(pid == 0){
			sleep(1);
			printf("id=%d user is quit\n",getpid());
			exit(EXIT_SUCCESS);
		}
	}

	sleep(2);/*父进程等待子进程结束*/
	return 0;
}
---------------------------------------------------------------**********************正常终止进程的五种方式：
①main中调用子进程运行完毕后加一个return
②执行exit(int status)函数，将status & 03777的结果返回给父进程。
③调用_exit(int status)或者_Exit(int status)函数
④进程的最后一个线程执行了返回语句
⑤进程的最后一线程调用pthread_exit()函数

_exit()与_Exit()这俩函数功能一样，第一个是UC函数（unistd.h）第二个是标C函数(stdlib.h),调用之后立即结束。参数为整数类型，负数代表非正常退出。_Exit()与exit()函数都是标准C函数，他们的区别是：exit()并不是立即退出，在退出之前会调用某些函数，只要用atexit(参数是函数指针)注册，退出之前就会被调用（即使不调用exit()正常return也会先调用atexit()注册的函数，而_Exit()则不会）。_Exit()则是立即退出，不会做任何额外的事。如果不是特别紧要，一般都调用exit()即可，在UC编程中，调用_exit()也可以。
*********************************非正常结束：
信号结束方式；
被其他进程取消最后一个线程。

----------------------------------------------------------------
父进程等待子进程结束后再执行的方法：（进程之间的调度）
函数wait()和waitpid()函数。 
#include<sys/wait.h>
pid_t wait(int * status);/*传出参数，传出子进程结束的状态*/
pid_t waitpid(pid_t idtype,id_t id,siginfo_t * infop,int options);
1、wait()函数用于父进程等待子进程的结束，子进程一旦结束，父进程也立即结束，否则wait()一直等待处于阻塞状态。如果父进程有多个子进程，则等待任意一个结束就返回，返回结束的子进程id，传出参数（也是返回）为传出结束的子进程的状态和退出码。wait()也可以回收僵尸进程，因此可使用wait()防止僵尸进程产生。

宏函数：
WIFEXITED(status)可以判断是否正常结束(正常结束返回真)；
WEXITSTATUS(status)取退出码（即exit的参数），后八位为有效（0~255）。