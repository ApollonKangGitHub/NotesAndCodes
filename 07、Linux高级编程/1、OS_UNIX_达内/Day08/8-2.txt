信号基本概念：
Ctrl+c、trl+\、kill -9 进程、段错误退出（内存非法访问等问题由信号11信号引发中断）、总线错误退出（文件映射出错引发信号中断）、int/0(引发浮点数例外错误，程序被信号中断)，等等都与信号有关系；信号是使程序中断的一种方式，属于软中断。

中断：就是终止当前代码转而执行其他代码，中断有软件中断与硬件中断。

信号的本质：是一系列非负整数（操作系统就是这么爱用整数）。UNIX常用信号1--48,Linux常用信号1--64。每个信号都有一个宏名称（宏变量），宏变量都是以SIG（signal）开头。信号的产生时间是无规律的，不知道什么时候回来，因此对于信号的处理采取异步处理方式（函数指针信号中断）。信号是不连续的；有些信号是不存在的；不同的操作系统，对应的信号的值时不同的（宏名是一样的），故在开发时应使用宏而不是使用数字以更好的兼容不同版本LINUX/UNIX。

eg：（LINUX）SIGINT是信号2，Ctrl+c产生的信号就是SIGINT，交由操作系统处理。

查看信号：
kill命令就是针对信号，可以发送信号：
kill -信号 进程ID：给某个进程发送信号（kill -9 pid就是给进程号为pid的进程发送SIGLIKK（9）信号）；
kill -l：显示所有信号。

信号中断结束程序属于非正常结束，可能会产生日志文件（段错误时括号里的那个“核心已转储”翻译不太清晰，英文是core dump（含义是异常日志文件已生成保存））。
----------------------------------------------------------------
信号分类：
①1--31都是不可靠信号，这种信号不支持排队，有可能丢失，是非实时信号
②34--64都是可靠信号，这种信号不支持排队，不会丢失，是实时信号

信号处理方式（三种）：
①默认处理：80%的默认处理都是中断进程
②忽略信号：可以忽略的信号，不作处理
③自定义处理：程序员写处理代码，想怎么处理就怎么处理。
注意：信号9不能被忽略，也不能被自定义，只能默认处理（退出），即使自定义了处理方式运行也不出错。
普通用户自能给自己的进程发信号，root可以给所有用户进程发送信号。

信号的处理方式可以使用signal()/sigaction()函数进行注册、设置。
----------------------------------------------------------------
#incldue<signal.h>

typedef void (*sighandler_t)(int);
sighandler_t signal(int signum,sighandler_t handler);

参数：
参数与返回值都是自定义函数指针（函数名作为指针），signum是具体的信号值。handler（处理方式）除了可以设为自定义函数指针，还可以设定为SIG_IGN（忽略信号）、SIG_DFL（默认处理方式）。

返回值：
成功返回信号处理的前值（return previous value of the signal handler），错误失败返回宏SIG_ERR。

子进程的信号处理：
fork()创建的子进程完全沿袭父进程对信号的处理方式（代码区共享，不存在子进程找不到父进程自定义的信号处理函数的情况）。而vfork()+exec创建的子进程：父进程忽略，子进程也会会略，但父进程自定义，子进程会改为默认（因为exec改变代码区之后，找不到父进程中自定义的处理函数）。
----------------------------------------------------------------
信号的发送方式：
1、键盘发送（只能发送部分）：
Ctrl+c -> 2 SIGINT
Ctrl+\ -> 3 SIGQUIT退出
Ctrl+z -> 20 SIGSTP暂停挂起

2、出错发送（只能发送部分）：
段错误 -> 11 SIGSEGV
总线错误 -> 7 SIGBUS
整数除以0 -> 8 SIGFPE
3、命令kill发送（可发全部）：
kill -SIG PID
信号0用来测试是否有权限发送信号（kill -0 1：普通用户无权限给init发送信号，而root用户有权限）
4、信号发送函数（基本可发全部）：
raise()、kill()、alarm()(只能发送部分)、sigqueue()(与sigaction()配合，并可以发送信号之外的东西)...
①raise()函数：
#include<signal.h>
int raise(int sig);
只能给自己发任何信号，给子进程也不能发送。成功返回0，失败返回非0。
----------------------------------------------------------------
sleep()成功返回0，当被信号终止时，会返回剩余未睡眠的秒数，单位是s
usleep()成功返回0，被信号终止返回-1，单位是μs
