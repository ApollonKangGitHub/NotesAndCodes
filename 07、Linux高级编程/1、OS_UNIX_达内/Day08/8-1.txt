回顾：
	fork()--通过复制父进程创建子进程，代码区不复制，其他区域都会复制。如果有文件描述符，只复制描述符不复制文件表。fork()创建子进程和父进程共享代码区。fork()之后父子进程同时运行，fork()并不确定父子进程谁先运行，也不确定谁先结束。
	wait()--父进程等待子进程的结束。如果有多个子进程，等待任一个结束就返回。
	pid_t wait(int * status);
	status 包括：是否正确结束   以及   退出码
	宏函数-----WIFEXITED(status)、WEXITSTATUS(status)
	进程的退出 -- 正常退出与非正常退出
	exit()、_exit()、_Exit()
----------------------------------------------------------------
1、waitpid():
pid_t waitpid(pid_t pid,int * status,int options);
/*waitpid可以完全代替wait；
waitpid(-1,&status,0); 等价于 wait(&status);*/
解析：wait只能等待第一个结束的便停止等待，而waitpid则可以指定（第一个参数pid）需要进行等待的子进程id；第二个参数与wait()相同。

参数：
pid:
	pid<-1：等待uid=|pid|进程组的子进程（负数代表的是进程组，取绝对值是其组id）；
	pid==-1：等待任意子进程；
	pid==0：等待和父进程同一进程组的子进程；
	pid>0：等待的子进程id为参数pid（指定子进程，其它三种不指定特定pid的子进程）。

statu: 
	和wait()是一样的
options:
	可取值为：WNOHANG(wait no hang),等待不挂起，没有子进程结束也直接结束，不会等待（父进程非阻塞意义不大）；一般options直接置零即可（置零为阻塞等待）。

返回值:
①成功（有子进程结束）返回结束的子进程pid；
②如果设置options为WNOHANG时没有子进程退出结束就返回0；
③失败返回-1。
----------------------------------------------------------------
2、vfork()：
pid_d vfork(void);/*just like fork()*/

区别：
①vfork()不复制父进程任何的内存空间
②vfork()确保子进程有限执行
vfork()创建的子进程占用父进程的内存空间运行。父进程在此时是阻塞的。vfork()要喝exec系列函数联合使用采用意义：vfork()负责创建子进程，而exec系列函数负责提供新的程序被执行。当vfork()创建的子进程执行新的程序时，父进程的内存空间就会被返回给父进程，父进程不再阻塞，父子进程同时运行。

经验：fork()创建的进程和父进程执行相同代码；当然fork()也可以与exec系列函数结合使用，但是我们不这样做（因为fork已经复制了与父进程独立的内存空间，不需要再exec画蛇添足、狗尾续貂了）
vfork()在有意的前提下，执行的代码与父进程无关，而是全新的代码；如果用vfork创建新的子进程与父进程执行相同的代码（选择的不同分支），还不如直接使用fork()。
----------------------------------------------------------------
exec系列函数（6种掌握一两种即可）：
exec本身不是函数，exec系列函数不是新建一个进程（不改变pid），而使用新的代码区堆区栈区以及数据区等替换旧的内存区（新程序修改就程序）。

#incldue<unistd.h>

/*掌握execl系列前两个即可p表示path，e表示env*/
int execl(const char * path,const char *arg,...);
int execlp(const char * file,const char *arg,...);/*不需要加PATH路径*/
int execle(const char * path,const char *arg,...,char * const envp[]);

前两个用法:execl("","","",...,NULL);
第一个参数是程序文件名以及路径（第二个可不加PATH路径）
第二个参数是命令
第三个参数是选项
第四个参数是参数
...
最后一个参数是NULL。

以NULL为结束（必须），表示有效参数就NULL前几个。
eg:execl("/bin/ls","ls","-la","/root",NULL);
或execl("ls","ls","-la","/root",NULL);
/*调用系统程序，当然也可以调用自己写的程序*/

注意：exec系列函数会更换代码区（代码区跳转，但不会在跳转回来），所以在同一进程中，exec系列函数后面的任何内容都不会执行。故在exec之后不需要加exit()。并且在加exec系列函数之后父子进程便遵循fork()的运行规则。
----------------------------------------------------------------
总结：
fork()--父子进程执行相同代码段，子进程结束需要exit();
vfork()+exec--父子进程执行不同代码段，且子进程不需要加exit().