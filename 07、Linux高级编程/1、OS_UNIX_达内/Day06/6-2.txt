mode类型与权限判断：
①类型判断（常用宏函数/宏变量均可判断）：
S_ISREG(m) 判断是否是普通文件
S_ISDIR(m) 判断是否是目录
S_ISLINK(m) 判断是否是软链接
S_ISSOCK(m) 判断是否是SOCKET文件
S_ISFIFO(m) 判断是否是管道文件
...
S_IFREG 普通文件
...
②权限判断：st.st_mode & 07777（取八进制后四位）
----------------------------------------------------------------
access函数可以判断文件的权限（读写执行）以及文件是否存在。
int access(const char * pathname,int mode);
/*
mode可选参数：
R_OK是否可读、W_OK是否可写、X_OK是否可执行、F_OK是否存在
返回值：
存在或具备该权限返回0，不具备权限或不存在返回-1
*/
----------------------------------------------------------------
权限设置函数：umask()
可以设置创建文件时的权限屏蔽字
mode_t umask(mode_t mode);
/*always succeeds,set new and return old*/
----------------------------------------------------------------
chmod()、fchmod()修改权限、chown...
truncate()/ftruncate()可以截取文件大小
remove()删除文件或目录（标C）
rename()修改文件名或目录名
一般带f与不带f的同类别函数区别在于不带f的函数文件名是字符串作为参数，而带f的函数文件时fd描述符作为参数。即一个需要首先open打开文件而利用fd，而另一个不需要打开文件。
----------------------------------------------------------------
mmap()映射文件：虚拟内存地址映射硬盘上的文件（物理内存可用较小但是硬盘足够大，所以映射文件可以解决物理内存不够用的问题即拿文件当内存使用不会占用内存资源）
void * mmap(void * addr,size_t length int prot,int flags,off_t offset);
写入内存的内容本质上就自动存入映射的文件中（MAP_SHARED才会，如果是MAP_PRIVATE则不能写入文件只能使用（其实写入文件只是在退出时自动清除不会保存）），但是要想写入文件，文件的大小必须足够大。
虽然mmap也可以读写文件，但是其主要作用是映射内存而不是读写件。
----------------------------------------------------------------
****************************************************************
―――――――――――――――――――――――――――――――――-
常用目录操作（4+2）#include<dirent.h>：
①mkdir()创建一个空目录；
②rmdir()删除一个目录（必须是空目录）；
③chdir()、fchdir()改变工作目录【cd】；
④getcwd()获取当前目录路径；

其它对于目录的操作：
读目录：
①DIR * opendir(const char * name);/*打开一个目录*/
②struct dirent * readdir(DIR *);/*读目录，依次返回目录的子项（一次返回一个，读一个目录指针后移一次），到目录底或出错返回NULL，出错会设置errno*/
struct dirent{
	ino_t d_ino;//子项的i节点
	off_t d_off;//节点的偏移量
	unsigned short d_reclen;//长度
	unsigned char d_type;//子项类型（常用）
	char d_name[256];//子文件名（常用）
	
};

rewinddir();
telldir();
seekdir();
/*注意：dirent.h为标准库，opendir、readdir等都是标准库函数*/
----------------------------------------------------------------
第六天作业：
1、完成目录名的递归打印
2、实现mylist的ls -l功能，注意：文件与目录的处理方式不同