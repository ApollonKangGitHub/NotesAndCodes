关于函数/线程的返回值：
①可以以指针作返回值，但是不能直接以数组作返回类型；
②可以返回局部变量，但是不能返回局部变量的指针；
③加了static的局部变量指针可以返回(加static就不再是局部变量)；
④线程的返回值必须是一个有效的指针。

线程的返回值可以用pthread_join()的第二个参数取得。
int pthread_join(pthread_t thread, void ** retval);
void ** retval可以取得void *类型的值(就好像int *类型的参数，可以取得int类型的值)。

该函数取返回值时，相当于代码：
	*retval = 线程返回值(返回值为void *类型)
****************************************************************
只要等号两边类型匹配即可，不一定非得是用指针类型的地址作为pthread_join的参数。也可以是整型的地址作为参数，对应的线程的函数返回值类型为(void *)int类型即可。
eg：
方式①
线程的函数中：
static int sum = 100;
return &sum;//指针类型
main函数中：
int *ret;//指针
pthread_join(id,(void **)&ret);
printf("%d\n",*ret);

等价于：*retval = *(&ret) = ret = &sum = 线程返回值;
即ret = &sum;//指针接收地址

方式②
线程的函数中：
int sum = 100;
return (void *)sum;//强转为指针类型
main函数中：
int ret;//整型
pthread_join(id,(void **)&ret);
printf("%d\n",ret);

等价于：*retval = *(&ret) = ret = (void *)sum = 线程返回值;
即ret = (void *)sum;//十进制整数接收十六进制整数
----------------------------------------------------------------
比较两个线程是否是一个线程，使用pthread_equal()函数
int pthread_equal(pthread_t tid1, pthread_t tid2);
相等返回0
否则返回非0
----------------------------------------------------------------
线程的终止：
不能使用exit()函数，因为exit()终止的是整个进程。
正常结束：函数结束，线程就结束；
人为结束：函数pthread_exit(void * retval)，参数类似于线程的retrun返回值类型；
非正常结束：出错/被其他线程取消。
----------------------------------------------------------------
线程的状态：
线程在启动后，可以通过不同的状态：
①调用pthread_join()函数，会进入非分离状态(同步)，非分离状态的线程会在pthread_join()结束后回收线程资源。
②调用pthread_detach()函数，会进入分离状态(异步)，分离状态的线程会在线程结束后/进入休眠,直接回收线程的资源(参考pthread_detach.c)。
已经处于分离状态的线程调用pthread_join()没有效果。线程最好处于这两种状态其中的一种。
int pthread_detach(pthread_t thread);
----------------------------------------------------------------
线程的取消(了解)：
结束与取消的区别类似于：while(1);与int x = 1;while(x);
线程的取消就是给目标线程发送CANCEL信号，目标线程有三种选择：
①忽略信号
②立即取消
③延后取消
线程取消的相关函数：
pthread_cancel()给目标线程发送取消信号
pthread_setcancelstate()设置是否支持取消(是否忽略)
pthread_setcanceltype()设置取消的方式(是否立即取消)
----------------------------------------------------------------
线程的同步：
因为多线程是共享进程的资源的，在访问共享的资源时，就有可能出现互相覆盖的情况，叫共享数据冲突。解决共享数据冲突的技术就叫线程同步，其解决方案为：把共享资源的访问代码由并行改为串行，其他代码依然并行。线程同步会降低线程的效率，因此使用时不是范围越大越好。

手段：互斥锁/互斥量：我们就可以在访问共享资源时加上互斥锁，访问共享资源结束之后释放互斥锁，就可以把并行改为串行。确保同一时刻只有一个进程在访问。互斥锁是线程规范的一个组成部分。

互斥量的使用步骤：
①声明互斥量：pthread_mutex_t lock;
②初始化互斥量：pthread_mutex_init(&lock,0);
或者在声明的同时初始化：
pthread_mutex_t lock = PHTHREAD_MUTEX_INITIALIZER;
③加锁：pthread_mutex_lock(&lock);
④访问、读写、使用
⑤解锁：pthread_mutex_unlock(&lock);
⑥销毁锁(释放资源)：pthread_mutex_destroy(&lock);