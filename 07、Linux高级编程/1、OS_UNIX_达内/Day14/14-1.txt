回顾：
网络编程 -- TCP、UDP单进程与多进程、与阻塞非阻塞通信
TCP一对多编程步骤：
Server:
①socket()
②struct sockaddr_in
③bind()
④listen()
⑤在循环中调用accept()
⑥读写操作：read()、write()/send()、recv()
⑦close()
Client:
不需要Server的③④⑤步，其它相同
****************************************************************
UDP编程步骤：(发送方/接收方)
Server：
①socket()
②struct sockaddr_in
③bind()
④读写操作：sendto()、recvfrom()/read()/recv()
⑤close()
Client:
不需要connect/bind，其它与Server端基本相同
----------------------------------------------------------------
多线程并行：
计算机程序运行的基本必备硬件：CPU与内存，如果要并行，意味着CPU的内存都应该可分。内存可分而CPU不可分，那么多线程如何并行？主流操作系统都采用CPU时间片轮转技术，实现多线程的宏观上(时间片)的并行、在微观上(时间点)仍然是串行。多线程互相独立又互相影响。主线程不直接影响其他线程，但主线程一旦结束，进程随之结束，进程结束导致其他线程结束。多线程之间代码是乱序执行，每个线程内部的代码是顺序执行的。
----------------------------------------------------------------
线程的代码实现：
POSIX规范中，对线程做了比较完善的定义，因此，线程编码使用pthread.h作为开发的头文件。在该头文件中几乎所有函数都以“pthread_”开头。比如:pthread_create()创建：

int pthread_create(pthread_t * thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
参数(四个指针)：
第一个：用于存储分配的线程ID，传出参数；
第二个：线程属性指针，默认属性写NULL；
第三个：接收任意类型指针返回任意类型指针的函数指针；
第四个：是第三个参数(函数指针)的参数。
函数指针指向的是线程将要执行的代码。我们在使用线程的参数时，必须保证参数的指向在线程运行中一直是有效的。

返回值：
成功返回0，错误返回错误编码。线程的函数错误处理通过直接返回错误码的方式，而不是使用errno记录错误码。

注意：Compile and Link with -lpthread or -pthread，因为线程相关的函数的代码都在libpthread.so共享库中。
在主函数中，使用函数指针调用函数，与在pthread_create()函数中，用函数指针作为参数执行函数的区别在于：一个是串行后者是并行。
----------------------------------------------------------------
int pthread_join(pthread_t thread, void ** retval);
join可以用来让一个线程(等待者)等待另外一个线程(被等待者)结束，并且取得被等待者的返回值；之后再结束等待者。如果不需要取被等待者的返回值，retval置为NULL即可。