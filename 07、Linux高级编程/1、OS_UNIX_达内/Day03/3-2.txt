*********************************************************
1、内存管理页机制：

最小存储单位是一个字节（1B），最小管理单位是一页（4KB），虚拟内存地址连续时物理内存地址可以不连续，即使一次分配6000字节（两页），两个内存页物理地址可能不挨着。多次申请内存时，如果之前分配的页内存没用完，则不再分配，除非之前分配的内存页用完才继续映射新的一页。硬盘也是如此：即使一个.txt文件中只有一个“a”字母，其大小为1B而其占用大小为4K。getpagesize()可以获取当前内存页的大小。

---------------------------------------------------------
/proc/进程ID文件/maps 文件存放了内存分页情况，注意：proc下各个进程目录占磁盘大小都是0，因为其数据都存在于内存，该文件只是一个映射。实际不存在。进程ID这个目录与子目录在对应pid的进程消亡后便会消失，所以可以用循环测试，并且maps文件中的内存地址为已经映射了物理内存的虚拟内存地址。
ps -aux 可以查看进程ID（ps -aux | grep 指定进程：查看指定进程pid等信息）

**********************************************************
2、内存分区：

#include<stdio.h>
#include<stdlib.h>

int i1 = 1;//全局区
int i2 = 2;//全局区
int i3;//BSS段
static int i4;//全局区
const int i5;//只读常量区
void fun(int i6)//i6在栈区，fun在代码区
{
	int i7;//栈区
	static int i8 = 8;//全局区
	const  int i9 = 9;//栈区
	int * pi = malloc(sizeof(int));//堆区
	char * str = "abcd";//只读常量区
	char str2[] = "abcd";//栈区
}
int main(void)
{
	fun(100);
	return 0;
}
----------------------------------------------------------
各个区域位置：在虚拟内存地址中，地址从小到大依次为：代码区->只读常量区->全局区->BSS段->堆区->栈区（堆区从小到大分配内存，栈从大到小分配内存）

**********************************************************
3、字符串

# include<stdio.h>
int main(void)
{
	char * s1 = "abc";/*s1在只读区，将abc地值赋给s1*/
	char s2[] = "abc";/*s2在栈中，将abc复制到了数组s2中*/

	strcpy(s1,"123");/*错误，s1指向常量区，不可改变内容*/
	s1 = "123";/*正确，可以修改地址*/

	strcpy(s2,"123");/*正确，数组元素可以改*/
	s2 = "123";/*错误，数组名为常指针，不可改地址*/
	
	char  * s3 = s2;/*s3指向栈区，即可修改地址（指向），又可修改值（指向的值）*/
	s3 = "abc";/*改地址*/
	strcpy(s3,"abc");/*改值*/

	char * s4 = malloc(sizeof(int));
	s4 = "abc";/*不报错，但int的四个字节地址丢了，使内存泄漏*/
	strcpy(s4,"abc");/*正确*/

}

----------------------------------------------------------
对于字符串赋值的操作：
=改变的是地址；
strcpy()改变的是值；
char * 指向只读区用 = 赋值，否则用strcpy赋值；
char []用 strcpy赋值；


*******************************************************
4、关于malloc和free：（注意分配和映射区别）
第一次malloc()时一次性映射33个内存页（Ubutun中），malloc()分配给变量内存时，除了数据区域外，还额外需要保存一些信息。底层有一个双向链表保存额外信息。malloc了16个字节，其中4个字节存放数据，另外12个存放其他信息或者空闲，若果将12个字节中前四个字节清空进行修改，free就可能出错，因为free只有首地址不能释放，还得需要额外信息（如malloc分配的长度）。（低四位是长度附加数据，中间四位是数据，高八位可能为空，可能为附加数据）
---------------------------------------------------------
int i;
int * p = &a;
*(p+1000) = 222;
printf("*(p+1000) = %d\n",*(p+1000));
可以打印出来222，因为1000*4=4000字节，并没有超出已分配（映射）的至少一页（4096字节）的物理内存。所以地址已经分配就可以使用。注意：int i;不一定分配内存页，这跟内存管理算法（机制）有关，一般有可能每次分配几十页，就是为了方便管理。