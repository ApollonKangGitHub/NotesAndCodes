**************************************
环境表操作函数：
char * getenv(const char * name)：
/*返回值为获取的环境变量首地址，name为需要匹配的字符串，只会去除“name=”的内容*/
int putenv(char * string)：
/*创建环境变量，存在就替换*/
int setenv(const char * name,const char *value,int overwrite)：	/*设置一个环境变量,三个参数，新建或替换覆盖（overwrite为0,位不替换；非零替换）*/
int unsetenv(const char * name);/*取消设置*/
int clearenv(void);/*清空*/


int main(int argc,char ** argv, char ** env)/*主函数三个参数*/
/*env和environ都是指向环境表首地址；而env只能在主函数中使用，extern char ** environ可以在任何函数中获取环境变量*/

eg:
char * value = getenv("PATH");
printf("%s\n",value);

putenv("KANGRUOJIN=123456");
printf("%s\n",get("KANGRUOJIN"));
setenv("KANGRUOJIN","ABCDEFG",0);//不替换
printf("%s\n",get("KANGRUOJIN"));
setenv("KANGRUOJIN","!@#$%^",1);//替换
printf("%s\n",get("KANGRUOJIN"));

**************************************
内存管理：
	Unix/Linux的用户层内存关系

STL->内存自动分配自动回收
  | 
C++->new和delete
  |
C语言->malloc()和free()
  |
Unix系统函数->sbrk()、brk()这俩函数既可分配又可回收
  |
Unix系统函数->mmap()分配、mumap()回收释放
---------------------------------------------
  |	内核层(C++方向了解、嵌入式需要掌握)
  |
kmalloc()、vmalloc()		
  |
get_free_page()

内存分配时函数自上而下调用
---------------------------------------------
进程和程序：
程序：在硬盘上的可执行的文件
进程：在内存中运行起来的程序

一个进程的内存空间包括以下几个部分：
（1）、代码区：程序的代码（函数）放入代码区，函数指针就指向代码区。为只读区。
（2）、全局区：用来存放全局变量和static静态变量，在main执行之前分配全局区，可读可写。
（3）、BSS段：存放未初始化的全局变量。main函数执行之前清空BSS段。
eg：
int i;//BSS段
int i = 1;//全局区
小知识点：全局变量未初始化打印为0，而局部变量未初始化打印为随机值。
（4）、栈区：非static的局部变量，包括函数的参数。内存是自动分配自动回收的。
（5）、堆区：也叫自由区，malloc()、free()操作堆区，程序员完全掌控堆区内存的分配和回收，容易产生内存的泄露。
（6）、常量区：常量和字符串的字面值（""）。
----------------------------------------------
虚拟内存地址：
每个进程都先天设定了4G的虚拟内存地址（不是真实的地址，只是一个编号）。虚拟内存开始时不对应任何内存，直接使用会引发段错误，不进入内核就接触不到物理内存地址，只会接触到虚拟内存地址。虚拟内存地址必须映射物理内存（或者硬盘上的文件）以后才能存储数据（数据存储在物理内存上，打印地址为虚拟内存地址）。而内存分配其实就是虚拟内存地址映射物理内存的过程，内存回收则是接触映射关系的过程。
虚拟内存中，0~3G是用户控件，3~4G是内核空间。用户层不能直接访问内核曾，可以通过Unix的系统函数访问内核层。
两个不同的进程，当其某个变量地址一样（虚拟），但是物理地址并不一样。