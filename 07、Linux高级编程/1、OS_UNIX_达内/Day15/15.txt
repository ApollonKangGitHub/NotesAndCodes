回顾：
线程 -- 线程原理(CPU时间片)、线程创建、线程的退出、线程参数和返回、线程同步-互斥量。
线程的创建函数：
pthread_create(&id, 0, 线程函数指针, 线程函数的参数);
void * mytask(void *); -- 线程函数的基本格式
在向task传参时，必须保证传入的指针有效。返回值时，也要保证返回的指针有效。线程创建以后，最好置成分离状态/非分离状态：
pthread_detach() -- 分离状态
pthread_join() -- 非分离状态
线程退出两种方式：线程函数中使用return或者pthread_exit(void *);
线程同步技术：
因为线程使用的内存是共享进程的，因此有可能出现共享数据的冲突，解决方案是：线程同步技术(核心理念：把并行访问改成串行访问)。互斥量是线程同步技术的一种。互斥量的使用步骤：

1、声明：pthread_mutex_t lock;
2、初始化：pthread_mutex_init()或者声明的同时赋值：pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
3、加锁pthread_mutex_lock()
4、读写
5、解锁pthread_mutex_unlock()
6、确定不再使用，释放互斥量pthread_mutex_destory();
----------------------------------------------------------------
信号量 -- 和signal无关，和信号量集无关；
信号量(semaphore):是一个计数器，用来控制访问临界资源的线程最大并行数量。当信号量的初始值为1时，效果等同于互斥量。该信号量不是最早的POSIX线程规范，因此信号量的相关定义实在semaphore.h中。semaphore.h中定义的信号量，是既可以用于进程又可以用于线程的。

信号量的使用步骤(与互斥量基本完全相似)：
①定义信号量：sem_t sem;
②初始化信号量 sem_init(&sem, 0, 计数的初始值);第二个参数0代表用于线程计数，其它值代表进程计数(进程计数Linux系统暂不支持)，初始值即最大线程数。
③获取信号量(计数-1):sem_wait(&sem);
④读写资源
⑤释放信号量(计数+1):sem_post(&sem);
⑥删除信号量：sem_destroy(&sem);
Link with -lrt or -pthread
----------------------------------------------------------------
死锁 -- 同步技术
init(m1)、init(m2)
A、B进程同时运行到第二个加锁，导致死锁。
A:
lock(m1)
...
lock(m2)<-----阻塞，等待m2资源
...
unlock(m2)
unlock(m1)

B:
lock(m2)
...
lock(m1)<-----阻塞，等待m1资源
...
unlock(m1)
unlock(m2)
多线程编程时必须避免死锁。避免死锁的经验(十二字箴言)：
顺序上锁、反向解锁、不要回调。
----------------------------------------------------------------
案例：基于TCP的聊天室
一个聊天室最多100人(listen监听队列长度100)
要求：
CLient：
①用户需要登录，登录时只需要输入一个昵称即可，昵称是否重复可判断也可不判断；
②用户登录后连接服务器端，进入聊天室
③用户可以输入聊天信息，也可以收到别人的聊天信息
④用户可以用某个特殊单词代表退出聊天室

Server：
①启动服务器，开放端口
②等待客户端的连接，每连接一个客户端，启动一个线程
③在线程中与客户端交互，交互过程：如果有客户端登录、退出、提交聊天，都应该发给所有客户端(需要保存accept返回的客户端的socket描述符)

额外功能：可以考虑TCP的文件传输(上传下载)