**********************************************************
1、动态调用共享库（动态编程）：
代码在运行时才知道调用那个函数，执行哪段代码。
相关函数#include<dlfcn.h>：
	（1）dlopen()：打开共享库
	（2）dlsym()：从打开的共享库文件中获得一个函数，返回函数指针，通过返回的函数指针调用相应的函数。
	（3）dlclose()：关闭共享库
	（4）dlerror()：错误处理

void * dlopen(const  char * filename, int flag);
/*类似open、fopen，文件名为库文件名；flag为RTLD_LAZY(延时从硬盘中加载，dlopen时不加载用的时候才会加载)或者RTLD_NOW）(diopen打开时立即加载)，加载就是将外部存储设备加载到内存，CPU方可处理；返回库文件的首地址*/

char * dlerror(void);/*类似于perror，用于观察上一个函数是否出错，出错返回出错信息字符串，未出错返回NULL*/

void * dlsym(void * handle,const char * symbol);/*handle为dlopen返回的地址，symbol为一个函数名，返回函数指针（函数的地址）*/

int dlclose(void * handle);/*关闭共享库*/

注意：在编译时，必须使用gcc test.c -ldl而不能直接gcc test.c

*********************************************************
2、错误处理：
C程序没有异常这个概念，因此错误处理有自己的一套机制，用返回值的不同体现错误。
****自己对错误的处理：
（1）、返回指针类型，一般用NULL代表错误（dlerror()用NULL代表成功，不代表错误；创建一个链表时，链表为空也会返回NULL，但不代表错误）。
（2）、返回int类型，一般用-1代表错误。
（3）、返回itn类型，正确的返回数据有可能是-1，-1就不能代表错误。用指针取数据，用返回-1代表错误，返回0代表正确。
（4）、不需要考虑错误处理，返回值设置成void即可
以上四种情况都是一般情况（惯例）。

举例：
a、打印传入的字符串；
b、测试传入字符串的值，如果不是error，返回“Success”，如果是error，代表出错，返回“Failure”；
c、返回0~10的随机数，如果随机到5，代表出错；
d、求两个整数的最大值，如果这两个整数相等，代表出错。


****C对错误的处理：
一个全局变量：errno -->错误编号，不包含错误信息；
三个函数：
strerror();-->把错误编号转换成错误信息
void perror(const char *s);-->自动找到错误变量并打印相应错误信息
void printf(const char *s,...);-->“%m”会自动打印错误信息

printf("open：%s",strerror(errno));
printf("open:%m");/*不会自动换行*/
perror("open");/*会自动换行*/
三者效果相同

errno初始值为0(SUCCESS)，在函数调用成功不会修改，依旧是之前的值，只有在错误时才会修改，并且errno并非所有函数都可以使用。

*********************************************************
环境变量和环境表：
所有的环境变量在程序中通过环境表获取；
环境表是一个全局变量，类型为字符串数组指针（二级指针），以NULL结束，获取方式：extern char ** environ;//envioron是环境表的首地址