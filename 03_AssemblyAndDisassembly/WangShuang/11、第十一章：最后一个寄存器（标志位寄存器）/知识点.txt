标志位寄存器中保存的是当前指令运算的信息状态，比如进位信息保存在CF标志位
注意：是运算结果的标志，比如add、sub、mul、div、and、or等，而mov、push等不会改变标志位寄存器。

;标志位寄存器信息状态表：
;==================================================================================================================|| 
标志	true				false				Name(名称)								命题					
;==================================================================================================================|| 
OF		OV(Overflow)		NV(Not Overflow)    Overflow Flag(是否溢出)					存在溢出？         			
;==================================================================================================================					
SF		NG(NeGative负的)	PL(Plus正的)		sign Flag(结果的符号是正还是负)			是负数(正数看做无符号)？	
;================================================================================================================== 
ZF		ZR(Zero)			NZ(Not Zero)    	Zero Flag(运算结果是否为0)				是0？
;================================================================================================================== 
PF		PE(Even偶数)		PO(Odd奇数)     	Parity Flag(结果中二进制位个数的奇偶性)	是偶数个1？    				
;================================================================================================================== 				
CF		CY(Carry yes)		NC(Not carry)   	Carry Flag(进位标志)					有进位？
;==================================================================================================================
DF		DN(Down)			UP(Up)              Direction Flag(方向标志)				si、di递减？			
;==================================================================================================================
;各标志位的位置：						
15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
				OF 	DF 	IF 	TF 	SF 	ZF		AF		PF		CF
;SF：判断依据是寄存器中最高位是否是1
;MUL指令不影响SF标志位
;进位与溢出本质是不一样的(进位是不能在存放下，而溢出是解析会出错)，CF与OF的区别：
;CF针对无符号数(将寄存器中的值都看作是无符号数)，而OF是针对有符号数(将寄存器中的值都看作是有符号数)
CF：0~255、0~65535
OF：-128~127、-32768~32767
;OF是两个操作数都当做有符号
;CF是两个操作数都当做无符号
eg:
①80H+81H:
对于signed：(-128)+(-127)=-255,超过[-128,127]的范围，OF为1
对于unsigned：(128)+(129)=257,超过[0,255]的范围，CF为1
②FCH+05H:
对于signed：(-4)+(5)=1,没有超过[-128,127]的范围，OF为0
对于unsigned：(252)+(5)=257,超过[0,255]的范围，CF为1
;===================================================================================
adc指令(add carry)：带进位加法
adc ax,bx	==> (ax)=(ax)+(bx)+CF
;eg:1E F000 1000H + 20 1000 1EF0H
mov ax,001EH
mov bx,0F000H
mov cx,1000H
add cx,1EF0H
adc bx,1000H
adc ax,0020H
;====================================
sbb指令:带借位减法
sbb ax,bx	==> (ax)=(ax)-(bx)-CF
;eg:003E 1000H - 0020 2000H
mov bx,1000H
mov ax,003EH
sub bx,2000H
sbb ax,0020H
;==========================================
CMP指令（compare比较指令）：影响标志位不保存结果到寄存器或者内存单元中。
①无符号数比较(检测zf和cf)：eg：cmp ax,bx ==> 查看(ax)-(bx)的结果(虽然不保存最终结果，但是暂存在CPU内部的暂存器上)
zf=1,说明(ax)=(bx)
cf=1,说明(ax)<(bx)
zf=0并且cf=0,说明(ax)＞(bx)
②有符号数比较(检测zf、sf和of)：eg：cmp ah,bh
sf=1并且of=0,说明(ah)<(bh)
sf=1并且of=1,说明(ah)>(bh)
sf=0并且of=1,说明(ah)<(bh)
sf=0并且of=0,说明(ah)≥(bh)
zf=0,说明(ah)=(bh)
;=======================================
条件转移指令：
;jcxz属于条件转移指令，但是它监测的是cx的值，而不是标志位寄存器。
;下面的条件转移指令属于根据检测不同标志位的值来决定是否转移的条件转移指令。
;并且这些条件跳转指令与cmp指令时配合使用的，没有cmp的话，这些指令没有直接意义
无符号数：
je	:等于则转移,检测zf=1
jne	:不等于则转移,检测zf=0
jb	:低于则转移,检测cf=1
jnb	:不低于则转移,检测cf=0
ja	:高于则转移,检测zf=0并且cf=0
jna	:不高于则转移,检测zf=1或cf=1
j:jump(跳),e:equal(等),b:below(低),a:above(高),n:not(不)
;eg:
;对于C语言的：					
short a=5,b=3;
if(a>b)	;if(a<=b)
	a=a+b;	
else
	a=a-b;
;类似的对于汇编来说可能就是：
mov ax,5
mov bx,3
cmp ax,bx
ja calc	;jna calc
sub ax,bx
jmp short over
calc:
	add ax,bx
over:
	...	
;与标志位有关的跳转指令：(cmp相关的五个标志位：cf、of、pf、sf、zf)
;这其中包含有符号与无符号
jz、jnz、je、jne、js、jns、jo、jno、jp、jnp、jb、jnb、jc、jnc、ja、jna
jg、jl、jpe、jle、jge、jpo、jae、jnae、jbe、jnbe、jng、jnge、jnl、jnle等等。
;=====================================================
movsb、movsw指令：
执行一次movsb等价于：
mov al ds:[si]
mov es:[di],al	;al只是一个中间temp，不一定是al
;df为0时自加，df为1时自减
inc si	;dec si
inc di	;dec di

执行一次movsw等价于:
mov ax ds:[si]
mov es:[di],ax	;ax只是一个中间temp，不一定是ax
;df为0时加，df为1时减
add si,2	;sub si2,
add di,2	;sub di,2

那么设置df标志位的指令为：
cld:置为0，clear df
std:置为1，set df

rep与movsb/movsw配合使用时，等价于：
rep movsb <==>
	s:
	movsb
	loop s
rep movsw <==>
	s:
	movsw
	loop s
;所以说用rep、movsb/movsw、cld/std指令的配合，在设定cx以后
;就可以自动完成我们自己用循环对ds到es的数据复制。
;============================================================
eg:将data段的前16个字节内容复制到后十六个字节
mov ax,data
mov ds,ax
mov es,ax
mov si,0
mov di,16

mov cx,16
cld
rep movsb
	/\
	||
	||
	\/
mov ax,data
mov ds,ax
mov es,ax
mov si,0
mov di,16

mov cx,16
s:
	mov al,ds:[si]
	mov es:[di],al
	inc si
	inc di
loop s
;======================================
pushf与popf指令：
pushf将标志寄存器的内容入栈
popf将栈中的值出栈到标志寄存器中

为直接访问标志寄存器提供了便利的方式。想使用哪一位就直接将其他位“and 0”与掉。