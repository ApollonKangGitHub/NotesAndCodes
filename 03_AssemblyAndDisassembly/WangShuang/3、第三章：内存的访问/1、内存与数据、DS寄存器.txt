1Byte = 8bit	(字节型数据)
1word = 2Byte = 16bit	(字型数据)

16位寄存器存储一个字，而在内存中需要两个空间连续的字节存储一个字。(高位地址存放高位数据，低地址存放低位数据)。 任何两个地址连续的内存单元，N号单元与N+1号单元可以看做两个内存单元，也可以看做一个地址为N的字单元中的低字节单元(N)和高字节单元(N+1)。
----------------------------------------------------------------
DS段地址寄存器：
存放要访问数据的段地址。

-e 2000:0000 11 22 33 44	//向2000:0000设置初始值
-a
mov bx,2000 
mov ds,bx
mov al,[0]	//debug中不能直接写成ds:[n]，而编辑器中可以这样写
mov cx,[1]	//并且编辑器中尽量写成ds:[n]更清晰

以上指令将2000:0000的字节型数据值读取到al寄存器中。将2000:0001的字型数据读取到cx寄存器中。[]表示内存单元，其中的0表示偏移地址，对哪个段偏移的呢？8086CPU会自动读取ds的数据最为内存单元的段地址。

最终的四条指令结果：
BX=2000
DS=2000
AX=0011
CX=3322

同样，DS和CS等段地址寄存器都是相通的，不支持将数据直接送进段地址寄存器中，要通过其它寄存器中转，这属于硬件设计问题。

当然，我们将[n]可以存向al/ax,也可以将al/ax存向[n]:
mov [0],al	//al字节型数据  
mov [2],ax	//ax字型数据，存入al->ds:[2]和ah->ds:[3]
add ax,[0]	//相加的结果保存到ax中
add [0],ax	//相加的结果保存到ds:[0]与ds:[1]的地址中
sub al,[0]	//相减的结果保存到al中
sub [0],ah	//相减的结果保存到ds:[0]的地址中
...
各种合理组合，都是可以的。
eg:
mov ds,1000
add ds,ax 
sub ds,ax
...等等都是不合理的
----------------------------------------------------------------
在内存中，数据与指令时完全没有区别的，而在寄存器中，数据与指令是有区别的，因为不同寄存提保存的是不同类型数据的地址(CS:IP保存指令数据地址，DS保存数据段地址...)而CPU负责读取CS：IP确定下一条指令存放的地址，读取DS得知将要处理的数据的段地址，根据指令中偏移地址找到具体数据。所以说，汇编程序通过CPU读取寄存器寻找指令与数据，进行一系列操作。