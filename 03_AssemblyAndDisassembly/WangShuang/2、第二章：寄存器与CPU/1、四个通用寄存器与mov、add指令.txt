CPU中核心部件：运算器、控制器、寄存器
我们汇编程序员就是通过汇编指令，来修改寄存器中的内容控制CPU，进步一控制各种内存而控制计算器进行各种操作。
debug
-r:查看寄存器编号

AX、BX、CX、DX：通用寄存器，一般存放数据(当然地址也算数据)
一个寄存器2Byte=16bit，可表示的值为0--65535
一个16位的通用寄存器可以分为2个8位的寄存器：高八位(H)和低八位(L)
AX = AH + AL
BX = BH + BL
CX = CH + CL
DX = DH + DL
----------------------------------------------------------------
练习：
简单执行以下步骤：
debug	(Enter)
-r	(Enter)	//查看以下寄存器初始值

-a	(Enter)
mov ax,4E20	(Enter)(Enter)	
//第一个回车时完成本次输入，第二个回车是完成-a的编辑
-t	(Enter)
可以看到4E20已经被写到AX寄存器中

-a	(Enter)
mov al,E4	(Enter)
mov bh,al	(Enter)
mov ch,ah	(Enter)
mov dx,ax	(Enter)(Enter)	//结束-a
-t	(Enter)
可以看到AX的4E20被修改为4EE4
-t	(Enter)
可以看到BX被修改为E400
-t	(Enter)
可以看到CX被修改为4E00
-t	(Enter)
可以看到DX被修改为4EE4
----------------------------------------------------------------
(注意：-t一次执行一条指令)
区分：
mov ax 1234	//12存入高八位，34存入低八位
mov ax 12	//12存入低八位
mov ax 0000	//00存入高八位，00存入低八位
mov ax 0	//0<==>0000，同上

上面是mov命令，add命令与mov命令基本相同，mov是覆盖寄存器中原有的值，而add是与寄存器中原有的值相加。
eg：
mov ax,1111
mov bx FFFE
mov ax,bx	//ax被覆盖为FFFE
add ax,1	//ax增加1后为FFFF
add bx,5	//bx增加5后溢出为0004
注意：寄存器可以在计算结果之后溢出，但是不能在计算结果之前给的值本身就是一个会溢出的值。
eg:
mov ax,FFFFF	//给的值本身就是超过范围的，错误
mov ax,FFFE
add ax,FFFE	//结果1FFFC，溢出后为FFFC
add ax,FFFFF	//给的值本身就是超过范围的，错误
mov ax,0089
add al,FF	//同理结果188H，溢出为88，AX=0088

可以写成：
mov ax FF、mov al,FF
但是不能写成：
mov al,00FF、mov ah,FF00、mov ax,bh等(即使bh的值小，ax空间大)

所以：当写成ax时，高八位与低八位是有关联的，但是写成ah或al时，高八位与低八位是独立的。(大的空间可以操作小的值，小的空间不能操作大的值；内部计算时溢出可以自行处理，外部提供操作数不能随心所欲；值的操作比较宽限，寄存器之间就比较狭隘)
注意：以上测试中溢出的值1并没有丢失，而是存到其它地方去了。
----------------------------------------------------------------