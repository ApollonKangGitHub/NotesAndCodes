debug中用-d查看地址：

格式：
段地址：偏移地址

对应寄存器：
段地址寄存器：DS、ES、SS、CS
偏移地址寄存器：SI、DI、BP、IP、SP、BX

由于8086CPU地址线有20根(20bit)，但是寄存器只有16bit，如何用16bit的寄存器保存20bit的地址？
物理地址 = 基础地址 + 偏移地址
基础地址 = 段地址 * 16	(段地址*10H)
eg：
073FH:0110H
对应的物理地址为：073FH * 10H + 0110H = 7500H

段地址:偏移地址 ==>只能得到一个物理地址
一个物理地址自 ==>可以分解不止一种"段地址:偏移地址"的组合
eg:
3000H:2000H ==>合并： 3000H * 10H + 2000H = 32000H
32000H ==>解析：3000H * 10H + 2000H
		2900H * 10H + 3000H
		3100H * 10H + 1000H
		3200h * 10h + 0000H
		......
偏移地址能表示的最大值为FFFFH

简单应用一：
给定段地址为0001H，那么只通过偏移地址的变化来寻址，cpu的寻址范围？
1H * 10H + (0H -- FFFFH) = 10H -- 1000FH
简单应用二：
有一数据存放在20000H单元中，设段地址为a，用段地址:偏移地址的方式能够找到20000H，那么a最大？最小？

a*10H + 0 >= 20000H	==> a_max = 2000H
a*10H + FFFFH <= 20000H	==> a_min = 1001H
----------------------------------------------------------------
CPU时如何区分数据和指令的？
CPU将CS:IP所组合出来的地址，其所存储的内容当做指令。

指令的执行过程：
①CPU从CS:IP所组成的地址中读取指令，将这个指令存放在指令缓存器中。
②IP = IP + 所读指令字节数(指令是有长度的，不同指令长度不尽相同，可以由多个字节组成。)
③执行指令缓存器中的内容，回到步骤①，重复这个过程。
以上三步在"-t"的时候按顺序分别执行，一气呵成。

----------------------------------------------------------------
转移指令：
能够修改IP或CS，或者同时修改的指令。格式：
jmp CS:IP
jmp IP

eg:
jmp 2000:20000	//同时修改
jmp 1000	//只修改了IP
mov ax,2000
jmp ax		//jmp借助寄存器

可以通过jmp修改CS和IP(jmp直接用值修改CS:IP或只修改IP)
也可以通过"mov cs,ax/bx/cx/dx"修改CS(mov借助通用寄存器修改)
但是不能同通过"mov cs,FFFF"修改CS(mov不能直接用值修改)
也不能通过mov修改IP(无论是借助通用寄存器，还是直接用mov修改)。

-a cs:ip	//从cs:ip开始写指令
-u cs:ip	//从cs:ip查看汇编指令与指令寄存器信息

jmp、call、ret等都有跳转的功能，只不过call和ret稍微复杂一点。