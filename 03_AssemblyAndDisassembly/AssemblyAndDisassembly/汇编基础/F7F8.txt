关于F7单步步入、F8单步步过的调试方式，以及Fake F8的反调试技术：

;F7单步步入：
遇到call指令会先保存当前指令的下一条指令的CS:IP到栈中，然后跳到子程序中去执行，子程序执行完毕后
从栈中获取到之前的call指令之后的指令地址，然后跳转回去等待下一步F7/F8输入执行call之后的指令
;F8单步步过：
直接越过call（不进入，CPU不中断执行），然后等待下一步F7/F8输入执行call之后的指令

原理：
断点，在某一处指令设置断点，是将该处的值改为0XCCH，即int 3H指令，程序在执行过程中如果遇到int 3Hz指令
不管当前以何种方式正在执行，也会暂停（比如断点在子程序内，按了F8单步步过执行，但是CPU在执行子程序时遇
到了子程序中间的0XCC也会停下来，等待处理）。

F7的原理:
按下F7单步步入，Debug根据键盘中断是F7键，得知要进行单步步入式执行方式，就将标志位寄存器的TF位设置为1；
因为CPU每次执行一条指令之后就回去检查TF的值，如果TF是1，则执行完本条指令后去执行中断(Debug的中断一般就是
输出一些信息)，中断执行完就暂停/等待下一次输入。所以F7将TF设置为1，则只执行一条指令就停止，并且进入call
以后也是如此。由于CPU只是判断TF标志位与int 3指令这两行种情况会暂停，而满足TF为1就已经满足暂停的充分条件
并且Debug会因为是F7所以设置TF为1，所以F7促成了单步步入式的调试形式。

F8的原理:
由于CPU不但在检测TF为1时暂停，也会在指令为int 3H时暂停，F8利用这种特点：
①按下F8键
②Debug根据是F8键设置TF为0，即不中断执行
③并且设置当前指令的下一条为int 3H(即将下一条的内存值改为0XCC)
④假如按F8时执行的是call则call之后的指令时int 3H，那么call中不间断执行(因为TF=0)
⑤而结束call只之后回到call之后的int 3H，CPU就暂停。

所以说F7与F8在普通指令中是一样的效果，而在call指令中是不同的效果，因为int 3H的设定位置的关系(当前指令的下一条指令)
并且Fake F8的反调试技术就是利用了这点，让反调试者不知道执行到了哪里。
