//1、为什么类里面的成员函数能够直接使用其成员变量？
因为编译器在编译时替我们将类（结构体）实例对象的地址传给了每一个成员函数，有了类对象的地址自然能访问任何一个成员。
也就是说即使成员函数没有参数，编译器也会自动获取类对象的地址作为参数，放在ecx中传递给所有成员函数(调用的传递，不调用编译器不处理)。
而传递的ecx中存放的地址就是所谓的"tihs"指针(类型为类的指针)。在成员函数中直接使用成员变量，其实就是缺省this指针的调用。

//2、既然this可以缺省，为何还要用this？
因为函数参数和类成员变量可以同名，this就是为了区分同名的函数参数与类成员变量的。
另外this的第二个个作用就是返回当前对象的地址。
注意：this是不能直接修改的，因为this只有一个作用就是直向当前对象。

//3、封装：将函数放到类之中就叫封装。
//4、对象：用封装的类定义一个变量，该变量就称作该类的一个实例对象。

//5、空类的大小为多少？有多个普通函数的大小是多少？有多个虚函数的大小又是多少？(均不考虑继承)
空类大小为1Byte(VC++6.0)；只有普通函数也是1Byte；多个虚函数是4字节(32系统)/8字节(64位系统)

//6、成员函数的调用约定与其它三种调用约定有何区别？
		//24:       C c;
		//25:       c.print(2);
		00401048 6A 02                push        2
		0040104A 8D 4D FC             lea         ecx,[ebp-4]//获取对象地址
		0040104D E8 D1 FF FF FF       call        @ILT+30(C::print) (00401023)
成员函数参数最少有一个，即this指针，用ecx传递；

//7、子类对象、父类对象、子类指针、父类指针：
可以用父类对象指向子类对象，但是不要(不建议)用子类指针指向父类对象。原因是：子类继承父类，拥有父类的成员，
用父类指针访问全无问题；但是子类指针访问父类对象，指针要访问的变量父类对象不一定存在其内存空间。

//8、子类父类重名成员变量：
子类中有父类同名的成员变量，编译器不管这个，在分配内存时就按照“子类变量个数+父类变量个数”来为子类对象分配内存。
而要访问重名的变量，需要用"对象.类名::重名变量"的形式访问，否则"对象.重名变量"默认访问的是离对象最近的类的该成员。
这种重名的变量尽量避免，即使难以避免也要使用类名加作用域运算符的方式去访问，而不要让编译器按默认去识别。

//9、多重继承与多层继承：
建议使用多层继承而不建议使用多重继承。因为多重继承即有多个父类，而这些父类的起始地址不同需要维护多个起始地址。
而多层继承每一层只有一个直接父类，所有的类起始地址是相同的，编译器不需要耗费太多“精力”去维护多个起始地址。

//10、struct与class：
struct默认成员是public的，class默认成员是private的。
struct默认继承是public继承方式，class默认继承是private继承方式。
但是无论何种权限的成员，何种继承方式都可以被继承，但是不一定能访问。
只要父类成员权限和子类继承方式中有任意一个是private的，子类对象都不能直接访问父类成员。

//11、函数直接调用与间接调用及其硬编码和特征:
call的地址紧跟在call指令后面为直接调用。对应硬编码为E8的call。直接调用编译时地址直接定死。
	对应C++中就是通过对象直接调用普通函数函数和虚函数/通过指针调用普通函数。
call的地址放在另外一个内存地址中为间接调用。对应硬编码为FF的call。间接调用的地址存在内存中不定死。
	对应C++就是通过指针调用虚函数。
也就是说虚函数在通过对象调用时是直接调用，在通过指针调用时是间接调用。

//12、单继承虚函数表表位置与特征：
虚函数表的地址在结构体/类的首地址开始的四字节中存储。
该四字节索引出的地址是虚函数表，虚函数表中存储的是虚函数的地址。虚函数表以0(NULL)结尾。

//13、虚函数表的访问
由于：虚函数表的创建在抽象基类的构造函数之后才完成。子类继承父类时，会覆写父类的同名虚函数。
所以：抽象基类的构造器与析构器也只能访问抽象基类自己的虚函数表。
但是在抽象基类的普通函数中，子类创建对象覆写基类虚函数完成，访问的是子类覆写后的虚函数表。