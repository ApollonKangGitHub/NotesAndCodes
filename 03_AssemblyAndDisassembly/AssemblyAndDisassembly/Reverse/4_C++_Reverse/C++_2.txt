//1、多继承的虚函数表
多继承即有n直接父类，如果这些父类均有虚函数则子类有n个虚函数表。
这些虚函数表的地址依次存放在类的初始地址开始的内存。
不存在覆写时，子类的函数地址存在第一张表中。
存在覆写时，子类函数覆写哪个基类函数就在哪张表中，没覆写的子类函数就依然在第一张表中。

//2、多重继承的虚函数表
与单继承的形式基本完全一样

//3、动态绑定：就是将函数调用与函数地址关联起来的动态过程

//练习测试：
class Base{
	public:
		int x;
	public:
		Base(){x = 100;}
		void Func_1(){printf("Base::Func_1()\n");}
		virtual void Func_2(){printf("Base::Func_2()\n");}
};
class Sub:public Base{
	public:
		int x;
	public:
		Base1(){x = 200;}
		void Func_1(){printf("Sub::Func_1()\n");}
		virtual void Func_2(){printf("Sub::Func_2()\n");}
};
void Test(Base * pb){
	printf("%d\n", pb->x);//成员变量：编译时绑定
	pb->Func_1();//普通函数：编译时绑定
	pb->Func_2();//虚函数通过指针调用：运行时绑定，动态绑定。
}
int main(void){
	Sub sub;
	Base base;
	
	Test(&sub);
	//打印结果为:
	//100
	//Base::Func_1()
	//Sub::Func_2()
	Test(&base);
	//打印结果为:
	//100
	//Base::Func_1()
	//Base::Func_2()
}
//描述上述动多态：
对于Test函数来说，没有进行调用时，不知道绑定的是哪个地址，因为没有实例就不存在虚函数表。
而实例调用时就产生了虚函数表，也知道了指针指向哪个表，绑定的地址也就确定知道了该调用哪个函数。
而一般就采用基类指针对子类对象进行虚函数调用。因为是虚函数，基类指针和子类指针指向同一虚表。
而基类指针又是通用的，可以单独写成函数，所有继承自抽象基类的子类都采用同一种方式调用就是多态的体现。

//如果一个基类是抽象基类，函数都是虚函数，不同子类进行覆写。则用基类指针指向哪个类就调用的是哪个类覆写的函数。
//如果不是抽象基类，函数是普通函数，子类不存在覆写。则用基类的指针无论指向基类还是指向子类。调用的函数都是基类的。
//多态：一种类型体现不同行为。多态就是动态绑定的体现，动态绑定就是多态的机理。

//4、赋值兼容：
①派生类的对象可以赋值给基类对象。
②派生类的对象可以初始化基类的引用。
③派生类对象的地址可以赋给指向基类的指针
//但是由于基类对象与基类引用的局限性，我们一般采用基类指针进行派生类对象的函数调用。
另外我们一般极少用到虚函数(因为继承层次少)，而虚函数经常存在与MFC/QT框架中。如QWidget:public QObject

//5、析构函数定义成虚函数：可以使得内存管理更加方便。这或许是平常开发中最直接用到的虚函数了。
