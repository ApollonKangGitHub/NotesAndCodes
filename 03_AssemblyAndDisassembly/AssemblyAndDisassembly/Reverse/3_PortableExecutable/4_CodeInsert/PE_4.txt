代码段增加代码：
bp + 函数名称:在OD/DTDebug里下断点

添加代码的思路(Addr为原OEP值，Addr2为添加的代码首地址)：
修改OEP为Addr1,Addr1:call Addr2,jmp Addr
E8、E9的硬编码:
E8 ADDR <==> call addr
E9 ADDR <==> jmp addr

注意：ADDR与addr不同，ADDR是公式计算出来的，而不是固定的地址
//addr = E8/E9当前地址(拉伸后的地址) +5 + ADDR
//ADDR = addr - (E8/E9的当前地址 + 5)
5是E8/E9 ADDR指令长度

比如，一个有四个参数(均为0)的函数地址为0X07564282,我们插入代码的首地址为0X05213468。
假设入口地址为：0X0100739D。则:
//push 0的硬编码为6A
0X07564282 - (0X05213470 + 5) = 0X02350E0D
0X0100739D - (0X05213475 + 5) = 0XFBDF3F23
05213460H:xx xx xx xx xx xx xx xx 6A 00 6A 00 6A 00 6A 00
05213470H:E8 0D 0E 36 02 E9 23 F3 DF FB 00 00 00 00 00 00

OEP改为0X05213468(注意修改时ImageBase的存在，需要加/减ImageBase的都要考虑到)

//===========================================================================================
新增加节：
必须满足条件：
SizeofHeaders - (DOS + 垃圾数据 + PE标记 + 标准PE头 + 可选PE头 + 已经存在节表) >= 2个节表元素的大小(80Byte)
也就是说现有SizeofHeaders必须有不少于80字节的空闲才可以增加一个节，因为40字节用来增加一个节表元素，
另外40字节是0，来满足格式要求(如果不满足，则需要重新对齐，将所有节往后移动)

需要修改的数据(不需要扩充SizeofHeaders的情况下)：
①添加的新的节表元素
②在新增加的节表元素后面填充40字节大小的0000
③修改NumberOfSections的值
④修改SizeofImage的值
⑤在原有数据的最后，新增加一个节的数据(内存对齐的整数倍)
⑥修正新增节表元素的属性与新增节对应

如果节表后面紧接着的数据不为0，说明该数据可能有用，就不能在该区域增加新的元素并将一个元素的内存置为0。
那么我们可以采用将从NT头到节表有效区域的所有数据向上移，和DOS头接住(0X40位置)，然后修改e_lfanew为0X40
并且将新的节表结束处到旧的节表结束处的内存(即向上移动的大小内存)全部置为零，就可以增加新的节表元素了。
该情况可以对比notepad.exe(原始)和notepad_new.exe(上移后)来分析：二者效果完全相同。
但是还有一种极端情况：
如果向上移动后空出来的不足以增加两个节表元素，我们还可以采用将从NT头到节表结束处的值复制到整个PE文件
结尾处的方式，并修改e_lfanew。这样做的好处是：在PE文件尾部可以随意增加新的节和节表元素，而不影响中间。
如果是在中间，则其后的所有内存需要因新增内存值而要偏移，并修改节表所有有关偏移的量，相当麻烦。

//===============================================================================================
