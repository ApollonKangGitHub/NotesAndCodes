DTDebug中：
F2下断点
F7单步步入
F8单步步过
Ctrl+G输入地址跳到指定地址处显示指令

简单的堆栈变换分析
;=============================================================================
;====================================eg1======================================
;功能：求两个数的和，用函数调用实现

;函数入口,value为传参，可以是内存中的、寄存器中的，也可以是立即数
0X????????	push value1		;堆栈传参，(寄存器传参也可以)
0X????????	push value2		;压栈顺序为参数列表从右到左
0X????????	call 0X********	;该call将下一条地址压入栈中，即返回地址
0X????????	add esp,8		;该步在返回后执行，调用完毕，传递的参数不需要再维护(堆栈平衡)
							;由于是函数返回之后再平衡的栈，则为外平栈(主调函数来平衡)
							;内平栈则是被调函数返回前进行平衡
							;而堆栈平衡为的是将公用的栈空间回复借用前的状态
			
;......

;下面的代码段即为函数
0X********:	push ebp	;保存原始栈底
0X????????	mov ebp,esp	;栈底提升(地址减小)，即设置被调函数的栈底，为被调函数提供函数栈
	
;设置缓冲区，40(64Byte)的大小不一定，编译器不同可能不同
;缓冲区是为了防止栈内存越界，影响函数返回地址
0X????????	sub esp,0X40

0X????????	push ebx
0X????????	push esi
0X????????	push edi	;保护现场
	
;缓冲区初始化，清除垃圾数据
0X????????	mov eax,0XCCCCCCCC
0X????????	mov ecx,0X10
0X????????	lea edi,dword ptr ss:[esp]
0X????????	;cld
0X????????	rep stos dword ptr es:[edi]
	
;ebp+4通常是返回地址
;ebp+8通常是第一个参数,ebp+C是第二个参数......
;ebp-4、ebp-8、...通常是局部变量
;核心功能只有两条指令
0X????????	mov eax,dword ptr ss:[ebp+8]	;value1
0X????????	add eax,dword ptr ss:[ebp+c]	;eax做返回值，eax存不下。用adc指令?
	
0X????????	pop edi
0X????????	pop esi
0X????????	pop ebx		;恢复现场
0X????????	mov esp,ebp	;恢复主调函数栈顶，降低栈底
0X????????	pop ebp		;恢复栈底
0X????????	retn		;pop eip

;汇编就基本完全是程序员借用寄存器维护内存。而C/C++是编译器替程序员完成内存维护的工作。

;=============================================================================
;====================================eg2======================================

;主调函数1
;将321压入堆栈，ESP = ESP - C
0X???????? push 3
0X???????? push 2
0X???????? push 1

0X???????? call 0X********
0X???????? add esp,0XC			;外平栈

;......

0X******** jmp 0X########	;编译器可能生成一个中间过渡指令

;......

;被调函数1/主调函数2
0X######## push ebp		;保存原始栈底
0X???????? mov ebp,esp	;设置被调函数栈底
0X???????? sub esp,0X48	;提升栈空间，缓冲区

0X???????? push ebx
0X???????? push esi
0X???????? push edi		;保存现场

0X???????? lea edi,dword ptr ss:[ebp-0X48]
0X???????? mov ecx,0X12
0X???????? mov eax,0XCCCCCCCC
0X???????? rep stos dword ptr es:[edi]	;初始化缓冲区

0X???????? mov dword ptr ss:[ebp-0X4],0X2	;栈底存一个值

0X???????? mov eax,dword ptr ss:[ebp + C]	;eax=2
0X???????? push eax
0X???????? mov ecx,dword ptr ss:[ebp + 0X8]
0X???????? push ecx				;取出函数的参数，作为新的函数的参数
0X???????? call 0X$$$$$$$$
0X???????? add esp,0X8		;堆栈平衡

0X???????? mov dword ptr ss:[ebp-0X8],eax	;返回值存储到栈中
0X???????? mov eax,dword ptr ss:[ebp-0X4]	
0X???????? add eax,dword ptr ss:[ebp-0X8]
0X???????? add eax,dword ptr ss:[ebp+0X10]	;2+d+3

0X???????? pop edi
0X???????? pop esi
0X???????? pop ebx
0X???????? add,esp,0X48

;该两行是VC++6.0编译器字节加上的，目的是检测堆栈平衡
0X???????? cmp ebp,esp	;堆栈平衡则ZF=1
0X???????? call 0X%%%%%%%%	

0X???????? retn

;......

;被调函数2：计算1+2+0X0A=d，eax传递返回值 
0X$$$$$$$$ push ebp		;保存原始栈底
0X???????? mov ebp,esp	;设置被调函数栈底
0X???????? sub esp,0X44	;提升栈空间，缓冲区

0X???????? push ebx
0X???????? push esi
0X???????? push edi		;保存现场

0X???????? lea edi,dword ptr ss:[ebp-0X44]
0X???????? mov ecx,0X11
0X???????? mov eax,0XCCCCCCCC
0X???????? rep stos dword ptr es:[edi]	;初始化缓冲区

0X???????? mov dword ptr ss:[esp-0X4],0X0A
0X???????? mov eax,dword ptr ss:[ebp+0X8]
0X???????? add eax,dword ptr ss:[ebp+0XC]	;加上另一个参数
0X???????? add eax,dword ptr ss:[ebp-0X4]	;加上0X0A

0X???????? pop edi 
0X???????? pop esi
0X???????? pop ebx	;恢复现场
0X???????? mov esp,ebp
0X???????? pop ebp	;恢复栈顶栈底
0X???????? retn

;......

0X%%%%%%%% jnz 0X&&&&&&&&	;堆栈不平衡则进行出错处理
0X???????? retn				;堆栈ZF = 1,平衡则不进行处理直接返回
0X&&&&&&&& ;......