//四条经典变长指令(以图1:硬编码格式.PNG参考指令格式)：
//后面操作对象必为寄存器，前面对象不定
88	mov Eb,Gb		
89	mov Ev,Gv

//前面对象必为寄存器，后面对象不定
8A	mov Gb,Eb
8B	mov Gv,Ev

//G:通用寄存器
//E:寄存器/内存
//b:字节
//v:word/double word/quadword(16/32/64位,取决于CPU模式)
//============================================================================================
//寄存器序号表：
0	1	2	3	4	5	6	7
000	001	010	011	100	101	110	111
AL	CL	DL	BL	AH	CH	DH	BH
AX	CX	DX	BX	SP	BP	SI	DI
EAX	ECX	EDX	EBX	ESP	EBP	ESI	EDI
//============================================================================================
由于仅通过OPCode不能知道到底是那条具体汇编指令。
这时就要在其后加一个ModR/M的一字节信息进行具体说明:
		//[7	6]	[5	4	3]	[2	1	0]
		//Mod		Reg/Opcode	R/M
3~5三位:主要用来确定"G"是哪一个寄存器
0~2和6、7五位：决定"E"是什么(寄存器/内存)
//============================================================================================
1、Opcode为88：
//eg:88 01:
	由88可以确定是：mov Eb,Gb格式; 
	Reg/Opcode:3~5位是000，即0号寄存器，8位(Opcode确定是8位)的0号寄存器即为al;
	Mod:67位为00，即为内存DS:[](00~01表示内存);
		//00-ds:[reg];01-ds:[reg+disp8];10-ds:[reg+disp32],11则表示寄存器
	R/M:001即ECX。以上三组均是通过查表得到的(表的规律基本是按照寄存器编号来的，但不全是);
	所以“88 01”的汇编指令即“mov byte ptr ds:[ecx],al”.
//eg2:88 10 <==> mov byte ptr ds:[eax],dl

//eg3:88 14 <==> mov byte ptr ds:[esp],dl但是这种解析时错误的。
	R/M解析的是esp，而如果R/M解析出100(ESP)时,是“88 ModR/M”的特例,不遵循“88 ModR/M”的指令格式。
	因为88的特殊情况指令长度(6字节)与普遍情况长度(2字节)不同，因此说88是变长指令(89、8A、8B也存在该特例)。
//eg4:88 15 <==> mov byte ptr ds:[ebp],dl但是这种解析也是错误的
	因为R/M解析为EBP时，就用立即数替换ebp了(但是解析方式是不变的，也算是一个小特例)。
		//eg:88 15 12 34 56 78 ==> mov mov byte ptr ds:[78563412],dl
//==========================================================================================
2、Opcode为89:
//eg:89 01(以32位CPU为准)
	由89可以确定是mov Ev,Gv格式;
	01 == 00 000 001 ==>Mod=00(DS:[]),Reg/Opcode=000(EAX),R/M=001(ECX)
	所以汇编指令为:mov dword ptr ds:[ecx],eax

3、8A/8B的解析步骤也是一样的。
//eg:8A 82 12 34 56 78
	①8A确定是mov Gb,Eb格式;
	②82 ==> 1000 0010 ==> 10 000 010三部分 ==> [reg+32disp32],eal,edx三部分
	③汇编指令为:"mov al,byte ptr ds:[edx+78563412]"

//==========================================================================================
//特殊情况:
当88/89/8A/8B后面的一字节"ModR/M"中"R/M"为100(ESP)时的特殊情况:
Opcode决定了后面有没有ModR/M，而ModR/M决定了后面有没有SIB。
不定长指令后有ModR/M，而ModR/M的Mod不为"11"且R/M值为"100"时则后面有SIB(参照图2:变长指令Mod)。

//eg:解析88 84 48 12 34 56 78：
	88 --> mov Eb,Gb	
	84 --> 1000 0100 --> 10 000 100 -->[reg+disp32],al,esp
	由于R/M解析出为ESP，所以不能按照"88 ModR/M"标准的格式[reg+disp32](即[reg]+disp32)
		应该是按照"disp32[-][-]"(即[--][--]+disp32)的形式解析
	那么[--][--]如何确定？就要根据SIB的一字节信息来确定了。SIB格式如下：
		//[7	6]	[5	4	3]	[2	1	0]
		//Scale	Index		Base
	//三部分拼成一个公式:"Base + Index*2^(Scale)"
		①Base三位(0~7)是寄存器编号为基址
		②Scale两位(0~3),只能是*1，*2，*4，*8
		③Index三位(0~7)也是寄存器编号为偏移/索引
	//那么接着分析：SIB=48H  -->  0100 1000 --> 01 001 000
		根据表3(参照图3:变长指令SIB)/公式和Base、Index、Scale来查找:
		Base:000寄存器编号为0的寄存器即"EAX"
		Scale(SS=01)与Index=001，查表得"ECX*2"
	//所以最终的指令为:
		mov byte ptr [eax+ecx*2+78563412],al
//eg2:解析88 74 8F AF：
	88 --> mov Eb,Gb	
	74 --> 0111 0100 --> 01 110 100 --> [reg+disp8],DH,ESP
	ESP不遵循"[reg+disp8]"格式，改为"[][]+disp8"格式:
	SIB = 8F --> 1000 1111 --> 10 001 111
	//Base + Index*2^(Scale):
	Base = 111H = 7(EDI)、Scale= 10H = 2、Index= 001H = 1(ECX)
	所以最终格式为:[EDI+ECX*4+AF]
	//所以最终的指令为(有符号):
	"mov byte ptr DS:[EDI+ECX*4+AF],DH"  ==>	mov byte ptr DS:[EDI+ECX*4-51],DH 
	注意与"mov byte ptr DS:[EDI+ECX*4+0AF],DH"的区别。
//或者查8F即"ECX*4"

//========================================================================================================
指令前缀:
	//1、段前缀:
	2E - CS  
	36 - SS
	3E - DS
	26 - ES
	64 - FS
	65 - GS
	//eg:
	2E 89 25 00 00 00 00 ==> mov dword ptr cs:[0],esp
	64 89 25 00 00 00 00 ==> mov dword ptr FS:[0],esp
	//注意:如果没有特殊说明,且
	//①[]里不存在ebp/esp/edi则默认为DS:[]
	//②[]里存在ebp/esp则默认为SS:[]
	//③[]里存在edi默认是ES:[],esi默认是DS:[]
	
	
	//2、操作指令前缀:修改默认长度
	66前缀修改32位长度为16位
	//eg:
	50 <==> push eax
	66 50 <==> push ax
	//这就是为什么没有专门为16位寄存器设计硬编码，一个前缀就搞定了
	
	//2、操作指令前缀:修改默认寻址方式
	67前缀修改操作数宽度(将操作数宽度改为16位)
	//eg:
	88 01 <==> mov byte ptr ds:[ecx],al
	67 88 01 <==> mov byte ptr ds:[bx+di],al
//根据白皮书的表2-2、2-3以及附表A-1~A-6八张表可以做一个反汇编引擎