段寄存器个数：8个，ES、DS、SS、CS、FS、GS、LDTR、TR(GDTR、IDTR这两个在Windows中没有用到)
GDTR、TR、LDTR、IDTR四个内存管理寄存器，来确定控制分段内存管理的数据结构的所在位置。
mov dword ptr ds:[0X123456],eax
真正读写的地址为：ds.base+0X123456
我们知道8个通用寄存器：EAX、EBX、ECX、EDX、ESP、EBP、EDI、ESI
和一个专用寄存器：EIP，一个标志位寄存器EFLAGS
;================================================
段寄存器ES、DS、SS、CS、FS、GS有96位其中80位不可见，16位可见：
struct SegMent{
	WORD Selector;		//16bit Selector	（可见部分）
	WORD Attributes;	//16bit Attributes	（属性）
	DWORD Base;			//32 Base			（段起始地址）
	DWORD Limit;		//32bit Limit		（段长度）
};
由于段寄存器可见部分只有16bit，所以读取时只能读取16位，但是写能写96位。
可以使用mov指令对除了LDTR和TR的段寄存器进行读写。

mov ax,ds	;读出来16位
mov ds,ax	;写进去96位，但是可见的16位由我们来写

读写LDTR的指令:SLDT/LLDT
读写TR的指令:STR/LTR
	
	Selector	Attribute	Base		Limit
ES	002B		可读可写	0			FFFFFFFF
DS	002B		可读可写	0			FFFFFFFF
SS	002B		可读可写	0           FFFFFFFF
CS  0023		可读可执行	0           FFFFFFFF
FS  0053		可读可写	7F83E000    FFF
GS  002B		可读可写	0           FFFFFFFF
除了cs的Attribute和fs的Base，其他的属性/值都是固定的(在同一台机器上)
;====================================================================
;eg:检测Attribute，要点：因为cs不可写
#include<stdio.h>
#include<Windows.h>
int main(void)
{
	int value = 0;
	__asm{
		mov ax,ss		//cs不可写，所以ss换成cs后运行会出错
		mov ds,ax
		mov dword ptr ds:[value],eax
	}
	return 0;
}
;eg:检测Base，要点：因为内存的0空间不可以访问
__asm{
	mov ax,fs		//换成其它寄存器就失败
	mov ss,ax
	mov ss:[0],eax
	mov ecx,ss:[0]
}
;limit测试，fs换成其它就可以，但fs运行会出错，因为100000超过了limit范围
__asm{
	mov eax,fs:[100000]
}
;====================================================================
GDT(全局描述符表)
LDT(局部描述符表)
GDTR寄存器有48位，存放GDT表的开始位置(32位)和长度(16位)。
GDT表中存放的是段描述符，每个段描述符8个字节，而段寄存器有96位(12字节)，可见的16位就是给定的16位
不可见的80位是根据段描述符表的段描述符确定的。
;如何确定？
首先我们在mov ds,ax时，源寄存器为ax是16位，这16位不仅放到可见的Selector中去，并且作为段选择子，
段选择子共16位，其第3~15位为index，确定段描述符在段描述表中的偏移量(以8字节为一个偏移)
即根据16位寄存器/16位内存(段选择子)来确定ds/ss/es/fs/gs的不可见的80位，但是段描述符只有8字节，
如何填充到80位(10字节)中去？(段描述符的某些域重复使用以及某一位(G)代表多个位)

;段选择子详解：
F E D C B A 9 8 7 6 5 4 3 |2 |1 0|
	index			      |TI|RPL|

第0、1位为RPL，为请求特权级别
第二位为TI，当TI=0查找GDT表、TI=1查找LDT表，由于Windows不存在LDT，所以TI一直为0
处理器将索引值index乘以8，再加上GDT或者/LDT的基地址，就是要加载的
;======================================================================================
除了mov指令，还有LDS、LES、LFS、LGS、LSS指令修改对应的段寄存器
由于CS与EIP属于一对儿配合使用的寄存器，所以不存在只修改CS的“LCS”指令
;eg:
char buffer[6];
__asm{
	les ecx,fword ptr ds:[buffer]	
	;高2个字节给ES，低四个字节给ECX
	;也就是说高两个字节(16位)作为了段选择子，在GDT中查找段描述符号所用
	;不能随便给，要是随便给则找到的也时无意义的段描述福
}
;注意上面的高两个字节的段选择子中的RPL(0、1两位)必须要小于等于对应的DPL(段描述符表的段描述符的高
;四字节的13、14位)否则会出错，但是我们要索引的就是段选择子，又怎么能知道其中的13、14位是什么，
;那只要设置RPL为0即可
word:2Byte
dword:4Byte
fword:6Byte
qword:8Byte
;===================================================================================================================
;段描述符详解:
;高四字节
位		31 32 30 29 28 27 26 25 24 |23 |22 |21 |20 |19 18 17 16 	|15 |14 13 |12 |11 10 9 8 |7 6 5 4 3 2 1 0
标识	Base 31:24				   |G  |D/B|0  |AVL|Seg Limit 19:16	|P  |DPL   |S  |Type  	  |Base 23:16
;低四字节
位		31 32 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 |15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
标识	Base Address 15:0								   |Segment Limit 15:0
;===================================================================================================================
p位：指定段描述符有效(1)无效(0)

;再看段寄存器的结构体：
struct SegMent{
	WORD Selector;	//16bit Selector	（可见部分），即段选择子
	WORD Attributes;//16bit Attributes	（属性），段描述符的8~23位
	DWORD Base;		//32bit Base		（段起始地址），段描述符高四字节的高8位与低8位以及低四字节的高16位)
	DWORD Limit;	//32bit Limit		（-------段长度），段描述符的高四字节的16~19位以及低四字节的低十六位
};
我们发现，Limit从段描述符表中似乎只获得了20位(FFFFF)，不足32位，其实不然。这就要说到段描述符标的G标志位：
G为0时，Limit的单位是字节，那么不足的12位补12个0(000FFFFF)
G位1时，Limit的单位是4KB，那么不足的12位补12个1(即FFFFFFFF)
注意：由于FS比较特殊，以后再说
而除了fs之外的几个段寄存器ES、DS、SS、CS、GS其Limit均为FFFFFFFF，说明G标志位均为1。
;===================================================================================================================
S位与Type域：
S位为1表示是代码段/数据段
S位为0表示是系统段
Type域为第8~11位，若第11位为0则是Data段，若第11位是1则是Code段

DPL(13、14位)要么全为0，要么全为1

由于段描述符要是代码段/数据段的，则：
P位首先为1(描述符有效)、S也为1(代码段/数据段)、DPL要么全为1要么全为0。
而“S、DPL、P”是描述符的高四字节的12~15位，即是描述符对应16进制的第五位(从高到低数)
而要想是代码段，则这所谓的：描述符对应16进制的第五位，则必须是F(1111)或9(1001)
那么只需要判断：描述符对应16进制的第五位是不是9/F，就知道该段描述符是不是代码段/数据段的但描述符
;并且我们已经能根据高四字节的第11位判断具体是codeseg(1)还是dataseg(0)，
;因此由于11位是四位一组中的最高位，所以可以根据描述符对应16进制的第六位，是大于等于8(codeseg)，还是小于8(dataseg)判断
eg：
;12345678
 8003F000 00000000		;F-->是代码段/数据段,进一步由F后面的0(0000)-->是数据段
 10021F00 997FC000		;1-->不是代码段/数据段
 2F029C00 1C7FC010		;9-->是代码段/数据段,进一步由9后面的C(1100)-->是代码段

;对于Type的8、9、10三位也有对应的属性：
如果是数据段(第十一位为0)：
8：A，表示是否访问过(访问过被置为1，否则为0)
9：W，表示是否可写(1表示可读可写，0表示只能读不能写)
10：E，拓展位(0表示向上拓展，1表示向下拓展)
所谓向上向下拓展的意义为：
向上(除了fs.base+limit之外的空间不可以使用)、向下(fs.base+limit之外的可以使用，但fs.base+limit范围内的空间不能使用)

如果是代码段(第十一位为1)：
8：A，与数据段相同
9：R，表示该段是否可读
10：C，一致位，C=1一致代码段、C=0非一致代码段
;===================================================================================================================
D/B位详解：
对CS、SS、向下拓展的数据段有影响。

(1)、对CS段的影响：
D=1，采用32位寻址方式
D=0，采用16位寻址方式
(2)、对SS段的影响：
D=1，隐式堆栈访问指令(push\pop\call)，使用32位堆栈指针寄存器ESP
D=0，隐式堆栈访问指令(push\pop\call)，使用16位堆栈指针寄存器SP
(3)、对向下拓展的数据段的影响：
D=1，向下拓展的上限为4GB
D=0，向下拓展的上限为64KB