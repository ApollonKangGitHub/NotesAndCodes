;高四字节
位		31 32 30 29 28 27 26 25 24 |23 |22 |21 |20 |19 18 17 16 	|15 |14 13 |12 |11 10 9 8 |7 6 5 4 3 2 1 0
标识	Base 31:24				   |G  |D/B|0  |AVL|Seg Limit 19:16	|P  |DPL   |S  |Type  	  |Base 23:16
;低四字节
位		31 32 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 |15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
标识	Base Address 15:0								   |Segment Limit 15:0
;===============================================================================================================================
(1)、CPL(Current Privilege Level)：当前特权级，CS/SS的后两位(段选择子后两位)即当前程序的特权级。只能是0和3，
因为Windows只使用了Intel的CPU四层中的0层与3层。0层是驱动程序，3层是应用程序。
(2)、DPL(Descriptor Privilege Level):描述符特权级别，DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么。
eg:mov ds,ax:如果AX指向的DPL=0，而当前程序的CPL=3，那么这行指令是不能成功的。(数值越大，权限越低)
(3)、RPL(Request Privilege Level):请求特权级，针对于段选择子而言，每个段选择子都有自己的RPL，可以自己随便指定。

mov ax,0008		与 		mov ax,000B		;段选择子
mov ds,ax				mov ds,ax		;对应上面，指向的是同一个段描述符，但是段选择子不同(段选择子的index相同，但RPL不同)
0000 0000 0000 1000		0000 0000 0000 1011
index=1，指向的都是第二个段描述符，但是如果段描述符的DPL为0，则:
mov ax,000B 
mov ds,ax
会失败
而，当段描述符的DPL为3，则两个都不会失败，都是可以的。
CPL在CS/SS的后两位，CS/SS的后两位在同一个程序中是相同的：CPU当前拥有的级别
DPL在段描述符中：如果你想访问我，你应当具有什么样的级别
RPL在段选择子中：设定什么样的权限去访问，会削弱CPL的权限
;数据段的权限检查：
CPL<=DPL并且RPL<=DPL
;代码段与系统段的检查方式与数据段不同
;===============================================================================================================================
;代码的跨段跳转：即同时修改CS与EIP
jmp far
call far
retf
int
iret
;段间跳转：
jmp\jcc：只修改EIP不修改ESP
call\ret：及修改EIP也修改ESP

;跳转步骤：拆分段选择子-->索引得到但描述符-->权限检查(隔绝权限不足的非法操作)-->加载段描述符-->代码执行
eg:
JMP 0X20:004183D7
(1)、段选择子为0X20，RPL=00、TI=0（GDT表）、Index=4
(2)、索引到的段描述符必须是：代码段、调用门、TSS任务段、任务门这四种情况才可以跳转。像数据段、其它系统段则不可以跳转。
因此这里的段选择子也不能随便给定。
(3)、如果是非一致代码段：CPL==DPL、RPL<=DPL,(一致非一致根据S位与Type的高两位决定)
如果是一致代码段（共享段，不要求修改数据，所以权限范围更宽）：CPL>=DPL
注意：
对于一致代码段：	
	特权级高的程序不能够访问特权级低的数据：核心态不允许访问用户态。
	而低特权级的程序可以访问高特权级的数据，但不能修改数据。
对于非一致性代码段：
	只允许同级访问。
(4)、通过检查后，权限允许，则CPU将段描述符加载到CS寄存器
(5)、CPU将CS.Base+Offset的值写入EIP，然后开始执行EIP开始处的代码。

;直接对代码段进行JMP/CALL的操作，无论目标是一致代码段还是非一致代码段，CPL都不会改变。一致代码段提供了共享的代码段。
;但要是想访问非一致代码段，就只能通过调用门提高CPL权限(减小值)。
测试这些步骤时，需要先查看GDT，才能跟据具体的段描述符来设置段选择子。
;===============================================================================================================================
;长调用与短调用：
短调用：
指令格式：call 立即数/寄存器/内存
发生改变的寄存器：ESP、EIP

;长调用(跨段不提权)：对应返回为长返回retf
指令格式：call CS:EIP（EIP被废弃）
不是EIP指定的，而是根据CS选择子索引出来的调用门计算出来的。
特点：跨段，但是不提权，即目的段与当前段属于同级别(CPL不改变)
发生改变的寄存器：ESP、EIP、CS(调用时压入当前指令下一条指令的CS、EIP,返回时出栈EIP、CS)	

;长调用(跨段并提权)：对应返回为长返回retf
指令格式：call CS:EIP（EIP被废弃）
特点：压栈顺序，调用者SS-->调用者ESP-->调用者的CS-->返回地址(下一条指令的EIP)
为什么要压SS:ESP，因为此时的栈是其它级别的另外一个栈，不是原来的栈，所以需要保存调用者级别的栈顶，以作返回
也就是说call前后的ESP一个是ESP_0,一个是ESP_3，老的SS:ESP保存后新的SS:ESP由TSS提供

;跨段调用时，一旦有权限的切换对应的是堆栈的切换。
;CS权限一旦改变，SS权限也要跟着改变
;JMP FAR只能跳转到同级非一致代码段，但是CALL FAR可以通过调用们提权，提升CPL的权限
;===========================================================================================================================
调用门执行流程：
(1)、根据CS的值查GDT表，找到对应的段描述符，这个描述符也是一个调用们
(2)、在调用门描述符中存储另一个代码段的段选择子
(3)、选择子指向的段，段.base+ 偏移地址就是真正的要执行的地址
S位为0，Type为1100的段描述符为门描述符。
调用门的最大价值就是跨段提权访问。

SGDT指令用来读取GDTR寄存器，虽然是为系统软件提供的，但是可以在3环使用，将读出的寄存器内容写入缓冲区。
;eg:该代码需要设置断点先查看Get_GDTRR_rgister()的地址，然后构造段描述符，并设置段描述符表
