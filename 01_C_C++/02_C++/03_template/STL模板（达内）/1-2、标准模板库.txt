1、回顾：模板(程序样板，实例化之后才能成为程序，不同的实例化得到的不同的函数和类，函数模板一般可以自动实例化，而类模板需要人为实例化。)重载，部分特化、偏特化、全特化、非类型形参，形参默认值。模板头<模板形参>、空模板template<>

标准模板库：
2、STL：
	HP公司总结提交编程委员会后，进行修改而加入标准库。STL高效、但是很少进行错误检查。STL(标准模板库)包括六大块：
	容器(container);
	迭代器(iteraor)：类似于指针，智能指针，将程序员从指针内存管理中解放出来;
	分配器(allocator)：一般使用默认的;
	容器适配器(adapter);
	算法(algorithm);
	仿函数(functor)：像函数一样但是不是函数。

避开直接的内存分配和指针操作，用迭代器来表示位置。迭代器就是对指针的封装，支持指针一样的最基本的操作(*取值操作、->操作、==、!=、++、--)但是++对于后加加不一定可以，对于--也是同样，并且--有可能不能使用(如单向链表)。支持++称为双向迭代器，个别迭代器还支持+一个整数称为随机迭代器。所谓迭代器是一种概念上的抽象，那些行为上像迭代器的东西都可以叫做迭代器，迭代器可以将容器与通用算法有机的结合起来，但是由于迭代器接口相同型号却不同，所以每一种容器都将迭代器内嵌于式定义于内部。

	区间：两个位置之间的数据称为一个区间，含头不含尾[起点,终点)，比如：[begin(),end())是最大的区间。


3、标准容器：
(1)、标准容器的共性(所有的容器(顺序、关联)都满足)：
	构造函数：无参构造、拷贝构造、区间构造(把一个区间中的数据都放到容器中)。	
	析构函数：释放容器的动态内存。
	运算符：赋值运算符=;比较运算符>、<、==、!=、>=、<=六个。
	交换：swap()，swap(a,b)与a.swap(b)相比成员函数更好点(量身定做)。
	插入：insert(pos,element)在指定位置插入元素element。
	删除：erase(pos)删除指定位置，erase(begin,end)删除指定区间的数据
	清空：clear()
	辅助函数：size()、empty()、max_size()等。
	迭代器：封装的指针，作为容器内部的类型，有四种：
			iterator：迭代器；
			const_iterator：只读迭代器；
			reverse_iterator：反向迭代器；	
			reverse_iterator：反向只读迭代器；
		迭代器的接口有四个(C++11中又增加了四个)：
			begin()返回第一个元素的迭代器；
			end()返回指向最后一个元素之后的迭代器；
			rbegin()返回指向反向的第一个元素的反向迭代器；
			rend()返回指向反向的最后一个元素之后的反向迭代器。
		[begin(),end())与[rbegin(),rend())是相反向的。
	容器会自己保存一份数据，因此自定义类型的数据如果要保存在容器中，则需要支持拷贝构造与赋值运算符函数针对自定义类型的重载(都有默认的，如果不是深拷贝就不必再自己重载一遍)。
(2)、序列式容器：
	vector向量/数组
	list链表、
	deque双端队列(double-ended-queue)
	//string基本字符序列,类似于向量，主要区别string对非迭代器式操作函数较多

①序列式容器的共性：
	增加的构造函数：指定个数相同元素初始化(默认0初始化);
	调整大小：resize()调整大小(截断/增加空间为初始化为0)，可能会改变容量。
	插入：insert(pos, n, element)//指定位置插入n个指定元素
	insert(pos, begin, end)//在指定位置插入相同容器的一段区间的元素
	重置(语义是赋值)：assign(n,val)/assign(begin,end)丢弃容器中原有数据。
	头尾：front()、back()返回序列的第一个/最后一个的元素
	尾部新增与删除：push_back()、pop_back()
②vector数组：一个动态数组，可以取代原始数组，适合在模板增加删除，不适合在中间插入删除，更不支持在头插入与删除。注意在插入数据容量变化时/删除数据时迭代器会失效，应重新取得迭代器。vector的迭代器是随机迭代器，当然也是双向迭代器。个性：支持[i]下标运算，不自动检查越界，at(i)会自动检查越界，并且会抛出异常，异常out_of_range肯定是exceptin的子类，所以catch可以接受exception的引用；capacity()容量，在gcc编译环境中默认最小为10，超过则成倍增加。reserve(n)设定容量避免频繁的重新分配与释放原有小的空间，当查过设置的n，则增加到2n(也是成倍增加)。

③deque双端队列：多个动态数组封装，相对于vector增加了pop_front()与push_front()对于头的操作。但是没有capacity()容量测试的函数。

④list链表：相对于vector，存在pop_front()与push_front(),remove(element)删除val等于element的所有元素；remove_if(bool functor(T))删除所有满足条件(返回true)的元素，unique()函数剔除相邻的重复元素。reverse()用来倒置链表，对于list来说本质是头尾指针互换。list.splice(pos, list2)将list2转移到list的pos位置；那么list2就空了，list.splice(pos,list2,pos2)将list2的pos2的未知的元素转移到list的pos位置；list.splice(pos,list2,beg,end)转移区间的元素，最后一个可以实现前两个的功能。merge()合并链表，前提是合并前是排好序的并且均为升序/降序,降序合并需要加参数说明。

(3)、关联式容器：
	set数据集
	multiset多重数据集
	map映射
	multimap多重映射

4、容器适配器：对序列式容器的再包装，进行了访问的限制(不能再随意访问)：
	stack栈(限制为先进后出):#include<stack>
	操作：push(),pop(),size(),empty(),top()
	queue队列(限制为先进先出):#include<queue>
	操作：push(),pop(),size(),empty(),front(),back()
	priority_queue优先队列(限制为谁大谁先出):#include<queue>
	操作：push(),pop(),size(),empty(),top(),其中top()是取最大的元素，而pop()是删除最大的元素。用大根堆实现(大根堆是一棵二叉树，特点：任意一个根节点节点比它的的左节点与右节点都大)，对应的有小根堆的树。

5、通用算法：大约有70种