C++中
编辑
C++与C#的static有两种用法：面向过程程序设计中的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。[1] 
面向过程
静态全局变量
在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。我们先举一个静态全局变量的例子，如下：
	
//Example1
#include<iostream>
usingnamespace std;
void fn();  //声明函数
static int n;  //声明静态全局变量
void main()
{
    n=20;  //为n赋初值
    printf("%d",n);//输出n的值
    fn();  //调用fn函数
}
void fn()
{
    n++;  //n的值自加一（n=n+1）
    printf("%d",n);  //输出n的值
}
静态全局变量有以下特点：
该变量在全局数据区分配内存；
未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为0）；
静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；
静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下图：
代码区 //low address全局数据区堆区栈区 //high address
一般程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。细心的读者可能会发现，Example 1中的代码中将
static int n; //定义静态全局变量
改为
int n; //定义全局变量
程序照样正常运行。
的确，定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量还有以下好处：
静态全局变量不能被其它文件所用；
其它文件中可以定义相同名字的变量，不会发生冲突；
您可以将上述示例代码改为如下：
	
//Example2
//File1第一个代码文件的代码
#include<iostream.h>
void fn();  //声明fn函数
static int n;  //定义静态全局变量
void main()
{
    n=20;
    cout<<n<<endl;
    fn();
}
//File2第二个代码文件的代码
#include<iostream.h>
extern int n;
void fn()
{
    n++;
    printf("%d",n);
}
编译并运行Example 2，您就会发现上述代码可以分别通过编译，但运行时出现错误。试着将
static int n; //定义静态全局变量
改为
int n; //定义全局变量
再次编译运行程序，细心体会全局变量和静态全局变量的区别。
注意：全局变量和全局静态变量的区别
1）全局变量是不显式用static修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过extern 全局变量名的声明，就可以使用全局变量。
2）全局静态变量是显式用static修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用extern声明也不能使用。
静态局部变量
在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。
我们先举一个静态局部变量的例子，如下
	
//Example3
#include<iostream.h>
#include<stdio.h>
void fn();
void main()
{
    fn();
    fn();
    fn();
}
void fn()
{
    static int n=10;
    printf("%d",n);
    n++;
}
通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。
但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。
静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。
静态局部变量有以下特点：
该变量在全局数据区分配内存；
静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；
静态函数
在函数的返回类型前加上static关键字，函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
静态函数的例子：
	
//Example4
#include<iostream.h>
static void fn();//声明静态函数
void main()
{
    fn();
}
void fn()//定义静态函数
{
    intn=10;
    printf("%d",n);
}
定义静态函数的好处：
静态函数不能被其它文件所用；
其它文件中可以定义相同名字的函数，不会发生冲突；
面向对象
（类中的static关键字）
静态数据成员
在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。先举一个静态数据成员的例子。

//Example5
#include<iostream.h>
class Myclass
{
    public:
        Myclass(int a,int b,int c);
        void GetSum();
    private:
        int a,b,c;
        static int Sum;//声明静态数据成员
};
int Myclass::Sum=0;//定义并初始化静态数据成员
 
Myclass::Myclass(int a,int b,int c)
{
    this->a=a;
    this->b=b;
    this->c=c;
    Sum+=a+b+c;
}
void Myclass::GetSum()
{
    cout<<"Sum="<<Sum<<endl;
}
void main()
{
    Myclass M(1,2,3);
    M.GetSum();
    Myclass N(4,5,6);
    N.GetSum();
    M.GetSum();
}
可以看出，静态数据成员有以下特点：
对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；
静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在Example 5中，语句int Myclass::Sum=0；是定义静态数据成员；
静态数据成员和普通数据成员一样遵从public,protected,private访问规则；
因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；
静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
<；数据类型><；类名>::<；静态数据成员名>=<；值>
类的静态数据成员有两种访问形式：
<；类对象名>.<；静态数据成员名> 或 <；类类型名>::<；静态数据成员名>
如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；
静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这 有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次， 则所有存款类对象的利息全改变过来了；
同全局变量相比，使用静态数据成员有两个优势：
静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；
可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；
静态成员函数
与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部 实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this 是缺省的。如函数fn（）实际上是this->fn（）。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指 针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。下面举个静态成员函数的例子。
	
//Example 6
#include <iostream.h>
class Myclass
{
    public : Myclass(int a,int b,int c);
    static void GetSum(); // 声明静态成员函数
    private : int a, b, c;
    static int Sum; //声明静态数据成员
}
int Myclass::Sum=0; //定义并初始化静态数据成员
Myclass::Myclass(int a,int b,int c)
{
    this->a = a;
    this->b = b;
    this->c = c;
    Sum += a + b + c; //非静态成员函数可以访问静态数据成员
}
void Myclass::GetSum() //静态成员函数的实现
{
    // cout<<a<<endl; //错误代码，a是非静态数据成员
    cout<<"Sum="<<Sum<<endl;
}
void main()
{
    Myclass M（1,2,3）;
    M.GetSum();
    Myclass N（4,5,6）;
    N.GetSum();
    Myclass::GetSum();
}
关于静态成员函数，可以总结为以下几点：
出现在类体外的函数定义不能指定关键字static；
静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
非静态成员函数可以任意地访问静态成员函数和静态数据成员；
静态成员函数不能访问非静态成员函数和非静态数据成员；
由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
调用静态成员函数，可以用成员访问操作符（.）和（->；）为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：
<；类名>::<；静态成员函数名>；（<；参数表>；）
调用类的静态成员函数。
作用
static静态变量声明符。在声明它的程序块，子程序块或函数内部有效，值保持，在整个程序期间分配存储器空间，编译器默认值0。
是C++中很常用的修饰符，它被用来控制变量的存储方式和可见性。
为什么要引入static
函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，大家知道，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题： 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。
什么时候用static
需要一个数据对象为整个类而非某个对象服务，同时又力求不破坏类的封装性，即要求此成员隐藏在类的内部，对外不可见。
内部机制
静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。
这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的main（）函数前的全局数据声明和定义处。
静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的“尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。
static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态
数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。
优势
可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。
应用格式
引用静态数据成员时，采用如下格式：
<；类名>::<；静态成员名>
如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员。
注意事项
⑴类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。
⑵不能将静态成员函数定义为虚函数。
⑶由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。
⑷由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X Window系统结合，同时也成功的应用于线程函数身上。
⑸static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。
⑹静态数据成员在<；定义或说明>；时前面加关键字static。
⑺静态数据成员是静态存储的，所以必须对它进行初始化。
⑻静态成员初始化与一般数据成员初始化不同：
初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；
初始化时不加该成员的访问权限控制符private，public等；
初始化时使用作用域运算符来标明它所属类；
所以我们得出静态数据成员初始化的格式：
<；数据类型><；类名>::<；静态数据成员名>=<；值>
⑼为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。在各通信公司的笔试面试中经常出现的考题就是static的作用及功能。
C语言中
编辑
static 函数内部函数和外部函数
当一个源程序由多个源文件组成时，C语言根据函数能否被其它源文件中的函数调用，将函数分为内部函数和外部函数。
内部函数
（又称静态函数）
如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数称为内部函数。
定义一个内部函数，只需在函数类型前再加一个“static”关键字即可，如下所示：
static 函数类型 函数名（函数参数表）{……}
关键字“static”，译成中文就是“静态的”，所以内部函数又称静态函数。但此处“static”的含义不是指存储方式，而是指对函数的作用域仅局限于本文件。
使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其它文件中的函数同名，因为同名也没有关系。
外部函数
外部函数的定义：在定义函数时，如果没有加关键字“static”，或冠以关键字“extern”，表示此函数是外部函数：
[extern] 函数类型 函数名（函数参数表）{……}
调用外部函数时，需要对其进行说明：
[extern] 函数类型 函数名（参数类型表）[，函数名2（参数类型表2）……]；
[案例]外部函数应用。
⑴文件mainf.c
main()
{
extern void input（…），process（…），output（…）；
input（…）；
process（…）；
output（…）；
}
⑵文件subf1.c
……extern void input（……） /*定义外部函数*/{……}
⑶文件subf2.c
……extern void process（……） /*定义外部 函数*/{……}
⑷文件subf3.c
……extern void output（……） /*定义外部函数*/{……}静态局部变量static的存储 有时希望函数中的局部变量的值在函数调用结束后不消失而继续保留原值，即其占用的存储单元不释放，在下一次再调用该函数时，该变量已有值（就是上一次函数调用结束时的值）。这时就应该指定该局部变量为“静态局部变量”，用关键字static进行声明。用静态存储要多占内存（长期占用不释放，而不能像动态存储那样一个存储单元可以先后为多个变量使用，节约内存），而且降低了程序的可读性，因此若非必要，不要多用静态局部变量。vb中语句
在过程级别中使用，用于声明变量并分配存储空间。在整个代码运行期间都能保留使用 Static 语句声明的变量的值。
static语句声明的变量，与dim语句声明的变量的主要区别是：前者只能在sub或function过程中使用，在退出sub或function过程后变量的值保留；后者使用在sub或function过程中时，退出sub或function过程后变量的值不保留。
语法Staticvarname[([subscripts])] [As [New]type] [,varname[([subscripts])] [As [New]type]] . . .
Static 语句的语法包含下面部分：
描述
varname 必需的。变量的名称；遵循标准变量命名约定。
subscripts 可选的。数组变量的维数；最多可以定义 60 维的多维数组。subscripts 参数使用下面的语法：
[lower To] upper [,[lower To] upper] . . .
如果不显式指定 lower，则数组的下界由 Option Base 语句控制。如果没有 Option Base 语句则下界为 0。
New 可选的。用它可以隐式地创建对象的关键字。如果使用 New 声明对象变量，则在第一次引用该变量时将新建该对象的实例，因此不必使用 Set 语句来对该对象引用赋值。New 关键字不能用来声明任何内部数据类型的变量，也不能用来声明从属对象的实例。
type 可选的。变量的数据类型；可以是
Byte、Boolean、Integer、Long、Currency、Single、Double、Decimal（目前尚不支持）、Date、String（对变长的字符串）、String * length（对定长的字符串）、Object、Variant、用户定义类型或对象类型。
所声明的每个变量都要有一个单独的 As type 子句。
说明
模块的代码开始运行后，使用 Static 语句声明的变量会一直保持其值，直至该模块复位或重新启动。可以在非静态的过程中使用 Static 语句显式声明只在该过程内可见，但具有与包含该过程定义的模块相同生命期的变量。
可以在过程中使用 Static 语句来声明在过程调用之间仍能保持其值的变量的数据类型。例如，下面的语句声明了一个定长的整型数组：
Static EmployeeNumber(200) As Integer
下面的语句为 worksheet 的新实例声明了一个变量：
Static X As New Worksheet
如果在定义对象变量时没有使用 New 关键字，则在使用该变量之前，必须使用 Set 语句将一个已有的对象赋给这个引用对象的变量。在被赋值之前，所声明的这个对象变量有一个特定值 Nothing，这个值表示该变量没有指向任何对象的实例。若在声明中使用了 New 关键字，则在第一次引用对象时将新建一个该对象的实例。
如果不指定数据类型或对象类型，且在模块中没有使用 Deftype 语句，则按缺省情况，定义该变量为 Variant 类型。
注意
Static 语句与 Static 关键字很相似，但是针对不同的效果来使用的。如果使用 Static 关键字（如 Static Sub CountSales （））来声明一个过程，则该过程中的所有局部变量的存储空间都只分配一次，且这些变量的值在整个程序运行期间都存在。对非静态过程而言，该过程每次被调用时都要为其变量分配存储空间，当该过程结束时都要释放其变量的存储空间。Static 语句则用来在非静态的过程中声明特定的变量，以使其在程序运行期间能保持其值。
在初始化变量时，数值变量被初始化为 0，变长的字符串被初始化为一个零长度的字符串 ("")，而定长的字符串则用 0 填充。Variant 变量被初始化为 Empty。用户自定义类型的变量的每个元素作为各自独立的变量进行初始化。
注意 如果在过程中使用 Static 语句，应和其它的声明语句（如 Dim）一样将其放在过程的开始。
作用
static的作用
在C语言中，static的字面意思很容易把我们导入歧途，其实它的作用有三条。
（1）先来介绍它的第一条也是最重要的一条：隐藏。
当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。为理解这句话，我举例来说明。我们要同时编译两个源文件，一个是a.c，另一个是main.c。
下面是a.c的内容
char a = 'A'; // global variable
void msg() {
printf("Hello\n");
}
下面是main.c的内容
	
int main(void)
{
extern char a; // extern variable must be declared before use
printf("%c ", a);
(void)msg();
return 0;
}
程序的运行结果是：
A Hello
你可能会问：为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。
如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。Static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用。
（2）static的第二个作用是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见，但我还是举一个例子。
	
#include <stdio.h>
int fun(void)
{
static int count = 10; // 此语句只在函数第一次调用时执行，后续函数调用此变量的初始值为上次调用后的值，每次调用后存储空间不释放
return count--;
}，
int count = 1;
int main(void)
{
printf("global\t\tlocal static\n");
for(; count <= 10; ++count)
printf("%d\t\t%d\n", count, fun());
return 0;
}
程序的运行结果是：
global local static
1 10
2 9
3 8
4 7
5 6
6 5
7 4
8 3
9 2
10 1
（3）static的第三个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’\0’太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’。不妨做个小实验验证一下。
	
#include <stdio.h>
int a;int main(void)
{
int i;
static char str[10];
printf("integer: %d; string: (begin)%s(end)", a, str);
return 0;
}
程序的运行结果如下
integer: 0; string: (begin)(end)
最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。
JAVA语言中
编辑
有时你希望定义一个类成员，使它的使用完全独立于该类的任何对象。通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字static（静态的）就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。你可以将方法和变量都声明为static。static 成员的最常见的例子是main（）。因为在程序开始执行时必须调用main() ，所以它被声明为static。
声明为static的变量称为静态变量或类变量。可以直接通过类名引用静态变量，也可以通过实例名来引用静态变量，但最好采用前者，因为后者容易混淆静态变量和一般变量。静态变量是跟类相关联的，类的所有实例共同拥有一个静态变量。
声明为static的方法称为静态方法或类方法。静态方法可以直接调用静态方法，访问静态变量，但是不能直接访问实例变量和实例方法。静态方法中不能使用this关键字，因为静态方法不属于任何一个实例。静态方法不能被子类的静态方法覆盖。
举例
如果你需要通过计算来初始化你的static变量，你可以声明一个static块，Static 块仅在该类被加载时执行一次。下面的例子显示的类有一个static方法，一些static变量，以及一个static 初始化块：
	
// Demonstrate static variables，methods，and blocks.
class UseStatic{ 
    static int a = 3; 
    static int b; 
    static void meth(int x) { 
        System.out.println("x = " + x); 
        System.out.println("a = " + a); 
        System.out.println("b = " + b); 
    } 
    static {
       System.out.println("Static block initialized.");
       b = a * 4;
    }
    public static void main(String args[]) {
      meth（42）； 
    }
}
一旦UseStatic 类被装载，所有的static语句被运行。首先，类属性变量开始赋值，a被设置为3，b默认初始化为 0 ，接着运行static 块，执行（打印一条消息），最后，b被赋值为a*4 或12。然后调用main（），main() 调用meth() ，把值42传递给x。3个println () 语句引用两个static变量a和b，以及局部变量x。
注意：在一个static 方法中引用任何实例变量都是非法的。
下面是该程序的输出：
Static block initialized
.x = 42
a = 3
b = 12
使用 static修饰符声明属于类型本身而不是属于特定对象的静态成员。static修饰符可用于类、字段、方法、属性、运算符、事件和构造函数，但不能用于索引器、析构函数或类以外的类型。例如，下面的类声明为 static，并且只包含 static方法。
例如：
	
static class CompanyEmployee{
     
     public static string GetCompanyName(string name) { ... }
     
     public static string GetCompanyAddress(string address) { ... }
 
}
一般来说，类中标注了static的函数与变量能在类外直接引用，比如说：
	
String M_string1 =CompanyEmployee.GetCompanyName(M_string2）
而没有标注static的函数则必须声明一个类的实体，有实体来引用。比如说：
	
static class CompanyEmployee{//静态类
    public string GetCompanyName(string name) { ... } //没有Static
    public static string GetCompanyAddress(string address) { ... }
}
CompanyEmployee M_CompE = new CompanyEmployee();
String M_string1 =M_CompE.GetCompanyName(M_string2）;//直接引用
 
　
C#语言中
编辑
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace MyNamespace
{
    class Program
    {
        public static void Main(string[] args)
        {
            Console.WriteLine("返回数组的和");
            int[] values = { 1,2,3,4,5};
            int sum = Sum(values);
            Console.WriteLine(sum);
         }
         //计算数组的和
         static int Sum(int[] valuesValue)
         {
             int sum = 0;
             for (int i = 0; i < valuesValue.Length; i++)
             {
             sum = sum + valuesValue[i];
              }
            return sum;
        }
    }
}
