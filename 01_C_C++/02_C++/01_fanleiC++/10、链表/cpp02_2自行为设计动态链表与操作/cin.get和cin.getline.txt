分为三种情况来看：
1）输入的字符串不超过限定大小
        get(str,Size)：读取所有字符，遇到'\n'时止，并且将'\n'留在输入缓冲区中，其将被下一个读取输入的操作捕获，影响该输入处理；
        getline(str,Size)：读取所有字符，遇到'\n'时止，并且将'\n'直接从输入缓冲区中删除掉，不会影响下面的输入处理。

2）输入的字符数超出限定的大小
        get(str,Size)：读取Size-1个字符，并将str[Size-1]置为'\0'，然后将剩余字符(包括'\n')留在输入缓冲区中，这些字符将被下一个读取输入的操作捕获，影响该输入处理；
        getline(str,Size)：读取Size-1个字符，并将str[Size-1]置为'\0'，剩余字符(包括'\n')留在输入缓冲区中，随即设置cin实效位(即if(!cin)的判断为真)，关闭输入。其后的所有输入都无法得到任何东西，当然也无法得到输入缓冲区中剩余的字符串。但如果象本例一样用clear()重置cin，其后的输入便可用并会得到遗留在输入缓冲区中的字符。

3）输入一个空行（即直接回车）
        get(str,Size)：str将得到'\0'，并设置cin实效位，关闭输入，但回车依然留在输入缓冲区中，因此如果我们用clear()重置cin，其下一个读取输入的操作将捕获'\n'；
        getline(str,Size)：str将得到'\0'，并将'\n'删除掉，不置实效位，不关闭输入。所以对于cin.getline来说空行是合法的输入，且不会影响下面的输入处理。

        至于使用那个更好，可能因人习惯不同而不同，仁者见仁智者见智。对于我们编程来说，总希望能有更好的容错性，即便用户输入了不合理的输入，程序也应该能够 提示并能够重新输入或继续正常处理，而因为用户的输入问题而导致程序错误或其后的所有输入都不可用显然不是我们希望的。使用get(str,Size)和 getline(str,Size)，都可能碰到设置失效位，关闭输入的情况，故都是需要考虑到相应的防错处理的。
		
		
		
		
//	cin >> ch2;//不能识别没越界的空格字符，自行认为是结束标志。也而不能识别月结字符
//	gets(ch2);//可以识别没越界的空格也是字符，但不能识别越界的字符
//	cin.get(ch2,12,'1');
//格式为cin.get(参数1，参数2，参数3);参数1数组名，参数2为数组长度，参数3为结束标志
//若不写参数3则默认结束（停止录入内存）标志为enter换行符
//可以识别没有越界的空格字符，越界的字符元素不进行写入内存符操作,
//而且数组有效元素个数为数组长度减1（即最后一个默认为'\0'）